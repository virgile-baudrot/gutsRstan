
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#include <rstan/rstaninc.hpp>
// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_ode_TKTD_varIT_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_ode_TKTD_varIT");
    reader.add_event(262, 262, "end", "model_ode_TKTD_varIT");
    return reader;
}

template <typename T0__, typename T1__>
int
find_interval_elem(const T0__& x,
                       const Eigen::Matrix<T1__, Eigen::Dynamic,1>& sorted,
                       const int& start_ind, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        int res(0);
        (void) res;  // dummy to suppress unused var warning

        stan::math::fill(res, std::numeric_limits<int>::min());
        int N(0);
        (void) N;  // dummy to suppress unused var warning

        stan::math::fill(N, std::numeric_limits<int>::min());
        int max_iter(0);
        (void) max_iter;  // dummy to suppress unused var warning

        stan::math::fill(max_iter, std::numeric_limits<int>::min());
        fun_scalar_t__ left;
        (void) left;  // dummy to suppress unused var warning

        stan::math::initialize(left, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(left,DUMMY_VAR__);
        fun_scalar_t__ right;
        (void) right;  // dummy to suppress unused var warning

        stan::math::initialize(right, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(right,DUMMY_VAR__);
        int left_ind(0);
        (void) left_ind;  // dummy to suppress unused var warning

        stan::math::fill(left_ind, std::numeric_limits<int>::min());
        int right_ind(0);
        (void) right_ind;  // dummy to suppress unused var warning

        stan::math::fill(right_ind, std::numeric_limits<int>::min());
        int iter(0);
        (void) iter;  // dummy to suppress unused var warning

        stan::math::fill(iter, std::numeric_limits<int>::min());


        stan::math::assign(N, num_elements(sorted));
        if (as_bool(logical_eq(N,0))) {
            return stan::math::promote_scalar<fun_return_scalar_t__>(0);
        }
        stan::math::assign(left_ind, start_ind);
        stan::math::assign(right_ind, N);
        stan::math::assign(max_iter, (100 * N));
        stan::math::assign(left, (get_base1(sorted,left_ind,"sorted",1) - x));
        stan::math::assign(right, (get_base1(sorted,right_ind,"sorted",1) - x));
        if (as_bool(logical_lte(0,left))) {
            return stan::math::promote_scalar<fun_return_scalar_t__>((left_ind - 1));
        }
        if (as_bool(logical_eq(0,right))) {
            return stan::math::promote_scalar<fun_return_scalar_t__>((N - 1));
        }
        if (as_bool(logical_gt(0,right))) {
            return stan::math::promote_scalar<fun_return_scalar_t__>(N);
        }
        stan::math::assign(iter, 1);
        while (as_bool((primitive_value(logical_gt((right_ind - left_ind),1)) && primitive_value(logical_neq(iter,max_iter))))) {
            {
            int mid_ind(0);
            (void) mid_ind;  // dummy to suppress unused var warning

            stan::math::fill(mid_ind, std::numeric_limits<int>::min());
            fun_scalar_t__ mid;
            (void) mid;  // dummy to suppress unused var warning

            stan::math::initialize(mid, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mid,DUMMY_VAR__);


            stan::math::assign(mid_ind, divide((left_ind + right_ind),2));
            stan::math::assign(mid, (get_base1(sorted,mid_ind,"sorted",1) - x));
            if (as_bool(logical_eq(mid,0))) {
                return stan::math::promote_scalar<fun_return_scalar_t__>((mid_ind - 1));
            }
            if (as_bool(logical_lt((left * mid),0))) {

                stan::math::assign(right, mid);
                stan::math::assign(right_ind, mid_ind);
            }
            if (as_bool(logical_lt((right * mid),0))) {

                stan::math::assign(left, mid);
                stan::math::assign(left_ind, mid_ind);
            }
            stan::math::assign(iter, (iter + 1));
            }
        }
        if (as_bool(logical_eq(iter,max_iter))) {
            if (pstream__) {
                stan_print(pstream__,"Maximum number of iterations reached.");
                *pstream__ << std::endl;
            }
        }
        return stan::math::promote_scalar<fun_return_scalar_t__>(left_ind);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct find_interval_elem_functor__ {
    template <typename T0__, typename T1__>
        int
    operator()(const T0__& x,
                       const Eigen::Matrix<T1__, Eigen::Dynamic,1>& sorted,
                       const int& start_ind, std::ostream* pstream__) const {
        return find_interval_elem(x, sorted, start_ind, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
linearInterp(const T0__& t_x,
                 const T1__& t_before,
                 const T2__& t_after,
                 const T3__& y_before,
                 const T4__& y_after, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        fun_scalar_t__ linInterp_hat;
        (void) linInterp_hat;  // dummy to suppress unused var warning

        stan::math::initialize(linInterp_hat, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(linInterp_hat,DUMMY_VAR__);


        stan::math::assign(linInterp_hat, (y_before + (((t_x - t_before) * (y_after - y_before)) / (t_after - t_before))));
        return stan::math::promote_scalar<fun_return_scalar_t__>(linInterp_hat);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct linearInterp_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& t_x,
                 const T1__& t_before,
                 const T2__& t_after,
                 const T3__& y_before,
                 const T4__& y_after, std::ostream* pstream__) const {
        return linearInterp(t_x, t_before, t_after, y_before, y_after, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
loglogistic_lpdf(const T0__& y_hat,
                     const T1__& alpha,
                     const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        return stan::math::promote_scalar<fun_return_scalar_t__>((((log(beta) - log(alpha)) + ((beta - 1) * (log(y_hat) - log(alpha)))) - (2 * log1p_exp((beta * (log(y_hat) - log(alpha)))))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
loglogistic_lpdf(const T0__& y_hat,
                     const T1__& alpha,
                     const T2__& beta, std::ostream* pstream__) {
    return loglogistic_lpdf<false>(y_hat,alpha,beta, pstream__);
}


struct loglogistic_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y_hat,
                     const T1__& alpha,
                     const T2__& beta, std::ostream* pstream__) const {
        return loglogistic_lpdf(y_hat, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
loglogistic_lcdf(const T0__& y_hat,
                     const T1__& alpha,
                     const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        return stan::math::promote_scalar<fun_return_scalar_t__>(-(log1p_exp((-(beta) * (log(y_hat) - log(alpha))))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct loglogistic_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y_hat,
                     const T1__& alpha,
                     const T2__& beta, std::ostream* pstream__) const {
        return loglogistic_lcdf(y_hat, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
loglogistic_lccdf(const T0__& y_hat,
                      const T1__& alpha,
                      const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        return stan::math::promote_scalar<fun_return_scalar_t__>(-(log1p_exp((beta * (log(y_hat) - log(alpha))))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct loglogistic_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y_hat,
                      const T1__& alpha,
                      const T2__& beta, std::ostream* pstream__) const {
        return loglogistic_lccdf(y_hat, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
std::vector<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type>
TKTD_varIT(const T0__& t,
               const std::vector<T1__>& y,
               const std::vector<T2__>& theta,
               const std::vector<T3__>& x_r,
               const std::vector<int>& x_i, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        fun_scalar_t__ kd;
        (void) kd;  // dummy to suppress unused var warning

        stan::math::initialize(kd, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(kd,DUMMY_VAR__);
        stan::math::assign(kd,get_base1(theta,1,"theta",1));
        validate_non_negative_index("dy_dt", "1", 1);
        vector<fun_scalar_t__> dy_dt(1);
        stan::math::initialize(dy_dt, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(dy_dt,DUMMY_VAR__);
        int Nconc(0);
        (void) Nconc;  // dummy to suppress unused var warning

        stan::math::fill(Nconc, std::numeric_limits<int>::min());
        stan::math::assign(Nconc,get_base1(x_i,1,"x_i",1));
        validate_non_negative_index("tconc", "Nconc", Nconc);
        Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  tconc(static_cast<Eigen::VectorXd::Index>(Nconc));
        (void) tconc;  // dummy to suppress unused var warning

        stan::math::initialize(tconc, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(tconc,DUMMY_VAR__);
        stan::math::assign(tconc,to_vector(stan::model::rvalue(x_r, stan::model::cons_list(stan::model::index_min_max(1, Nconc), stan::model::nil_index_list()), "x_r")));
        validate_non_negative_index("conc", "Nconc", Nconc);
        Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  conc(static_cast<Eigen::VectorXd::Index>(Nconc));
        (void) conc;  // dummy to suppress unused var warning

        stan::math::initialize(conc, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(conc,DUMMY_VAR__);
        stan::math::assign(conc,to_vector(stan::model::rvalue(x_r, stan::model::cons_list(stan::model::index_min_max((Nconc + 1), (2 * Nconc)), stan::model::nil_index_list()), "x_r")));
        int pulse_index(0);
        (void) pulse_index;  // dummy to suppress unused var warning

        stan::math::fill(pulse_index, std::numeric_limits<int>::min());
        stan::math::assign(pulse_index,find_interval_elem(t,tconc,1, pstream__));
        fun_scalar_t__ conc_linInterp;
        (void) conc_linInterp;  // dummy to suppress unused var warning

        stan::math::initialize(conc_linInterp, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(conc_linInterp,DUMMY_VAR__);
        stan::math::assign(conc_linInterp,(logical_neq(pulse_index,0) ? stan::math::promote_scalar<fun_scalar_t__>(linearInterp(t,get_base1(tconc,pulse_index,"tconc",1),get_base1(tconc,(pulse_index + 1),"tconc",1),get_base1(conc,pulse_index,"conc",1),get_base1(conc,(pulse_index + 1),"conc",1), pstream__)) : stan::math::promote_scalar<fun_scalar_t__>(get_base1(conc,1,"conc",1)) ));


        stan::math::assign(get_base1_lhs(dy_dt,1,"dy_dt",1), (kd * (conc_linInterp - get_base1(y,1,"y",1))));
        return stan::math::promote_scalar<fun_return_scalar_t__>(dy_dt);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct TKTD_varIT_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        std::vector<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type>
    operator()(const T0__& t,
               const std::vector<T1__>& y,
               const std::vector<T2__>& theta,
               const std::vector<T3__>& x_r,
               const std::vector<int>& x_i, std::ostream* pstream__) const {
        return TKTD_varIT(t, y, theta, x_r, x_i, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
solve_TKTD_varIT(const std::vector<T0__>& y0,
                     const T1__& t0,
                     const std::vector<T2__>& ts,
                     const std::vector<T3__>& theta,
                     const std::vector<T4__>& tconc,
                     const std::vector<T5__>& conc,
                     const std::vector<T6__>& odeParam, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        validate_non_negative_index("x_i", "1", 1);
        vector<int> x_i(1, 0);
        stan::math::fill(x_i, std::numeric_limits<int>::min());


        stan::math::assign(get_base1_lhs(x_i,1,"x_i",1), size(tconc));
        return stan::math::promote_scalar<fun_return_scalar_t__>(to_matrix(integrate_ode_rk45(TKTD_varIT_functor__(), y0, t0, ts, theta, to_array_1d(append_row(to_vector(tconc),to_vector(conc))), x_i, pstream__, get_base1(odeParam,1,"odeParam",1), get_base1(odeParam,2,"odeParam",1), get_base1(odeParam,3,"odeParam",1))));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct solve_TKTD_varIT_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const std::vector<T0__>& y0,
                     const T1__& t0,
                     const std::vector<T2__>& ts,
                     const std::vector<T3__>& theta,
                     const std::vector<T4__>& tconc,
                     const std::vector<T5__>& conc,
                     const std::vector<T6__>& odeParam, std::ostream* pstream__) const {
        return solve_TKTD_varIT(y0, t0, ts, theta, tconc, conc, odeParam, pstream__);
    }
};

class model_ode_TKTD_varIT : public prob_grad {
private:
    int n_group;
    int n_data_conc;
    vector<double> conc;
    vector<double> tconc;
    vector<int> idC_lw;
    vector<int> idC_up;
    int n_data_Nsurv;
    vector<int> Nsurv;
    vector<int> Nprec;
    vector<double> tNsurv;
    vector<int> idS_lw;
    vector<int> idS_up;
    double hb_meanlog10;
    double hb_sdlog10;
    double kd_meanlog10;
    double kd_sdlog10;
    double rel_tol;
    double abs_tol;
    int max_num_steps;
    int proper_distribution;
    double alpha_meanlog10;
    double alpha_sdlog10;
    double beta_minlog10;
    double beta_maxlog10;
    vector<double> y0;
    vector<double> odeParam;
    vector<double> tNsurv_ode;
    vector<double> tconc_ode;
public:
    model_ode_TKTD_varIT(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_ode_TKTD_varIT(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_ode_TKTD_varIT_namespace::model_ode_TKTD_varIT";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "n_group", "int", context__.to_vec());
            n_group = int(0);
            vals_i__ = context__.vals_i("n_group");
            pos__ = 0;
            n_group = vals_i__[pos__++];
            context__.validate_dims("data initialization", "n_data_conc", "int", context__.to_vec());
            n_data_conc = int(0);
            vals_i__ = context__.vals_i("n_data_conc");
            pos__ = 0;
            n_data_conc = vals_i__[pos__++];
            validate_non_negative_index("conc", "n_data_conc", n_data_conc);
            context__.validate_dims("data initialization", "conc", "double", context__.to_vec(n_data_conc));
            validate_non_negative_index("conc", "n_data_conc", n_data_conc);
            conc = std::vector<double>(n_data_conc,double(0));
            vals_r__ = context__.vals_r("conc");
            pos__ = 0;
            size_t conc_limit_0__ = n_data_conc;
            for (size_t i_0__ = 0; i_0__ < conc_limit_0__; ++i_0__) {
                conc[i_0__] = vals_r__[pos__++];
            }
            validate_non_negative_index("tconc", "n_data_conc", n_data_conc);
            context__.validate_dims("data initialization", "tconc", "double", context__.to_vec(n_data_conc));
            validate_non_negative_index("tconc", "n_data_conc", n_data_conc);
            tconc = std::vector<double>(n_data_conc,double(0));
            vals_r__ = context__.vals_r("tconc");
            pos__ = 0;
            size_t tconc_limit_0__ = n_data_conc;
            for (size_t i_0__ = 0; i_0__ < tconc_limit_0__; ++i_0__) {
                tconc[i_0__] = vals_r__[pos__++];
            }
            validate_non_negative_index("idC_lw", "n_group", n_group);
            context__.validate_dims("data initialization", "idC_lw", "int", context__.to_vec(n_group));
            validate_non_negative_index("idC_lw", "n_group", n_group);
            idC_lw = std::vector<int>(n_group,int(0));
            vals_i__ = context__.vals_i("idC_lw");
            pos__ = 0;
            size_t idC_lw_limit_0__ = n_group;
            for (size_t i_0__ = 0; i_0__ < idC_lw_limit_0__; ++i_0__) {
                idC_lw[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("idC_up", "n_group", n_group);
            context__.validate_dims("data initialization", "idC_up", "int", context__.to_vec(n_group));
            validate_non_negative_index("idC_up", "n_group", n_group);
            idC_up = std::vector<int>(n_group,int(0));
            vals_i__ = context__.vals_i("idC_up");
            pos__ = 0;
            size_t idC_up_limit_0__ = n_group;
            for (size_t i_0__ = 0; i_0__ < idC_up_limit_0__; ++i_0__) {
                idC_up[i_0__] = vals_i__[pos__++];
            }
            context__.validate_dims("data initialization", "n_data_Nsurv", "int", context__.to_vec());
            n_data_Nsurv = int(0);
            vals_i__ = context__.vals_i("n_data_Nsurv");
            pos__ = 0;
            n_data_Nsurv = vals_i__[pos__++];
            validate_non_negative_index("Nsurv", "n_data_Nsurv", n_data_Nsurv);
            context__.validate_dims("data initialization", "Nsurv", "int", context__.to_vec(n_data_Nsurv));
            validate_non_negative_index("Nsurv", "n_data_Nsurv", n_data_Nsurv);
            Nsurv = std::vector<int>(n_data_Nsurv,int(0));
            vals_i__ = context__.vals_i("Nsurv");
            pos__ = 0;
            size_t Nsurv_limit_0__ = n_data_Nsurv;
            for (size_t i_0__ = 0; i_0__ < Nsurv_limit_0__; ++i_0__) {
                Nsurv[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("Nprec", "n_data_Nsurv", n_data_Nsurv);
            context__.validate_dims("data initialization", "Nprec", "int", context__.to_vec(n_data_Nsurv));
            validate_non_negative_index("Nprec", "n_data_Nsurv", n_data_Nsurv);
            Nprec = std::vector<int>(n_data_Nsurv,int(0));
            vals_i__ = context__.vals_i("Nprec");
            pos__ = 0;
            size_t Nprec_limit_0__ = n_data_Nsurv;
            for (size_t i_0__ = 0; i_0__ < Nprec_limit_0__; ++i_0__) {
                Nprec[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("tNsurv", "n_data_Nsurv", n_data_Nsurv);
            context__.validate_dims("data initialization", "tNsurv", "double", context__.to_vec(n_data_Nsurv));
            validate_non_negative_index("tNsurv", "n_data_Nsurv", n_data_Nsurv);
            tNsurv = std::vector<double>(n_data_Nsurv,double(0));
            vals_r__ = context__.vals_r("tNsurv");
            pos__ = 0;
            size_t tNsurv_limit_0__ = n_data_Nsurv;
            for (size_t i_0__ = 0; i_0__ < tNsurv_limit_0__; ++i_0__) {
                tNsurv[i_0__] = vals_r__[pos__++];
            }
            validate_non_negative_index("idS_lw", "n_group", n_group);
            context__.validate_dims("data initialization", "idS_lw", "int", context__.to_vec(n_group));
            validate_non_negative_index("idS_lw", "n_group", n_group);
            idS_lw = std::vector<int>(n_group,int(0));
            vals_i__ = context__.vals_i("idS_lw");
            pos__ = 0;
            size_t idS_lw_limit_0__ = n_group;
            for (size_t i_0__ = 0; i_0__ < idS_lw_limit_0__; ++i_0__) {
                idS_lw[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("idS_up", "n_group", n_group);
            context__.validate_dims("data initialization", "idS_up", "int", context__.to_vec(n_group));
            validate_non_negative_index("idS_up", "n_group", n_group);
            idS_up = std::vector<int>(n_group,int(0));
            vals_i__ = context__.vals_i("idS_up");
            pos__ = 0;
            size_t idS_up_limit_0__ = n_group;
            for (size_t i_0__ = 0; i_0__ < idS_up_limit_0__; ++i_0__) {
                idS_up[i_0__] = vals_i__[pos__++];
            }
            context__.validate_dims("data initialization", "hb_meanlog10", "double", context__.to_vec());
            hb_meanlog10 = double(0);
            vals_r__ = context__.vals_r("hb_meanlog10");
            pos__ = 0;
            hb_meanlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "hb_sdlog10", "double", context__.to_vec());
            hb_sdlog10 = double(0);
            vals_r__ = context__.vals_r("hb_sdlog10");
            pos__ = 0;
            hb_sdlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "kd_meanlog10", "double", context__.to_vec());
            kd_meanlog10 = double(0);
            vals_r__ = context__.vals_r("kd_meanlog10");
            pos__ = 0;
            kd_meanlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "kd_sdlog10", "double", context__.to_vec());
            kd_sdlog10 = double(0);
            vals_r__ = context__.vals_r("kd_sdlog10");
            pos__ = 0;
            kd_sdlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "rel_tol", "double", context__.to_vec());
            rel_tol = double(0);
            vals_r__ = context__.vals_r("rel_tol");
            pos__ = 0;
            rel_tol = vals_r__[pos__++];
            context__.validate_dims("data initialization", "abs_tol", "double", context__.to_vec());
            abs_tol = double(0);
            vals_r__ = context__.vals_r("abs_tol");
            pos__ = 0;
            abs_tol = vals_r__[pos__++];
            context__.validate_dims("data initialization", "max_num_steps", "int", context__.to_vec());
            max_num_steps = int(0);
            vals_i__ = context__.vals_i("max_num_steps");
            pos__ = 0;
            max_num_steps = vals_i__[pos__++];
            context__.validate_dims("data initialization", "proper_distribution", "int", context__.to_vec());
            proper_distribution = int(0);
            vals_i__ = context__.vals_i("proper_distribution");
            pos__ = 0;
            proper_distribution = vals_i__[pos__++];
            context__.validate_dims("data initialization", "alpha_meanlog10", "double", context__.to_vec());
            alpha_meanlog10 = double(0);
            vals_r__ = context__.vals_r("alpha_meanlog10");
            pos__ = 0;
            alpha_meanlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "alpha_sdlog10", "double", context__.to_vec());
            alpha_sdlog10 = double(0);
            vals_r__ = context__.vals_r("alpha_sdlog10");
            pos__ = 0;
            alpha_sdlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "beta_minlog10", "double", context__.to_vec());
            beta_minlog10 = double(0);
            vals_r__ = context__.vals_r("beta_minlog10");
            pos__ = 0;
            beta_minlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "beta_maxlog10", "double", context__.to_vec());
            beta_maxlog10 = double(0);
            vals_r__ = context__.vals_r("beta_maxlog10");
            pos__ = 0;
            beta_maxlog10 = vals_r__[pos__++];

            // validate, data variables
            check_greater_or_equal(function__,"n_group",n_group,1);
            check_greater_or_equal(function__,"n_data_conc",n_data_conc,1);
            for (int k0__ = 0; k0__ < n_group; ++k0__) {
                check_greater_or_equal(function__,"idC_lw[k0__]",idC_lw[k0__],1);
            }
            for (int k0__ = 0; k0__ < n_group; ++k0__) {
                check_greater_or_equal(function__,"idC_up[k0__]",idC_up[k0__],1);
            }
            check_greater_or_equal(function__,"n_data_Nsurv",n_data_Nsurv,1);
            for (int k0__ = 0; k0__ < n_group; ++k0__) {
                check_greater_or_equal(function__,"idS_lw[k0__]",idS_lw[k0__],1);
            }
            for (int k0__ = 0; k0__ < n_group; ++k0__) {
                check_greater_or_equal(function__,"idS_up[k0__]",idS_up[k0__],1);
            }
            // initialize data variables
            validate_non_negative_index("y0", "1", 1);
            y0 = std::vector<double>(1,double(0));
            stan::math::fill(y0,DUMMY_VAR__);
            validate_non_negative_index("odeParam", "3", 3);
            odeParam = std::vector<double>(3,double(0));
            stan::math::fill(odeParam,DUMMY_VAR__);
            validate_non_negative_index("tNsurv_ode", "n_data_Nsurv", n_data_Nsurv);
            tNsurv_ode = std::vector<double>(n_data_Nsurv,double(0));
            stan::math::fill(tNsurv_ode,DUMMY_VAR__);
            validate_non_negative_index("tconc_ode", "n_data_conc", n_data_conc);
            tconc_ode = std::vector<double>(n_data_conc,double(0));
            stan::math::fill(tconc_ode,DUMMY_VAR__);

            stan::math::assign(get_base1_lhs(y0,1,"y0",1), 9.9999999999999995e-21);
            stan::math::assign(get_base1_lhs(odeParam,1,"odeParam",1), rel_tol);
            stan::math::assign(get_base1_lhs(odeParam,2,"odeParam",1), abs_tol);
            stan::math::assign(get_base1_lhs(odeParam,3,"odeParam",1), max_num_steps);
            for (int gr = 1; gr <= n_group; ++gr) {

                stan::model::assign(tNsurv_ode, 
                            stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), 
                            stan::model::rvalue(tNsurv, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "tNsurv"), 
                            "assigning variable tNsurv_ode");
                stan::math::assign(get_base1_lhs(tNsurv_ode,get_base1(idS_lw,gr,"idS_lw",1),"tNsurv_ode",1), (get_base1(tNsurv,get_base1(idS_lw,gr,"idS_lw",1),"tNsurv",1) + 1.0000000000000001e-09));
                stan::model::assign(tconc_ode, 
                            stan::model::cons_list(stan::model::index_min_max(get_base1(idC_lw,gr,"idC_lw",1), get_base1(idC_up,gr,"idC_up",1)), stan::model::nil_index_list()), 
                            stan::model::rvalue(tconc, stan::model::cons_list(stan::model::index_min_max(get_base1(idC_lw,gr,"idC_lw",1), get_base1(idC_up,gr,"idC_up",1)), stan::model::nil_index_list()), "tconc"), 
                            "assigning variable tconc_ode");
                stan::math::assign(get_base1_lhs(tconc_ode,get_base1(idC_lw,gr,"idC_lw",1),"tconc_ode",1), (get_base1(tconc,get_base1(idC_lw,gr,"idC_lw",1),"tconc",1) + 1.0000000000000001e-09));
            }

            // validate transformed data
            for (int k0__ = 0; k0__ < 1; ++k0__) {
                check_greater_or_equal(function__,"y0[k0__]",y0[k0__],0);
            }

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            ++num_params_r__;
            validate_non_negative_index("sigma", "3", 3);
            num_params_r__ += 3;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_ode_TKTD_varIT() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("beta_log10")))
            throw std::runtime_error("variable beta_log10 missing");
        vals_r__ = context__.vals_r("beta_log10");
        pos__ = 0U;
        context__.validate_dims("initialization", "beta_log10", "double", context__.to_vec());
        double beta_log10(0);
        beta_log10 = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(beta_log10);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_log10: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "3", 3);
        context__.validate_dims("initialization", "sigma", "double", context__.to_vec(3));
        std::vector<double> sigma(3,double(0));
        for (int i0__ = 0U; i0__ < 3; ++i0__)
            sigma[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < 3; ++i0__)
            try {
            writer__.scalar_unconstrain(sigma[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            T__ beta_log10;
            (void) beta_log10;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_log10 = in__.scalar_constrain(lp__);
            else
                beta_log10 = in__.scalar_constrain();

            vector<T__> sigma;
            size_t dim_sigma_0__ = 3;
            sigma.reserve(dim_sigma_0__);
            for (size_t k_0__ = 0; k_0__ < dim_sigma_0__; ++k_0__) {
                if (jacobian__)
                    sigma.push_back(in__.scalar_constrain(lp__));
                else
                    sigma.push_back(in__.scalar_constrain());
            }


            // transformed parameters
            T__ hb_log10;
            (void) hb_log10;  // dummy to suppress unused var warning

            stan::math::initialize(hb_log10, DUMMY_VAR__);
            stan::math::fill(hb_log10,DUMMY_VAR__);
            stan::math::assign(hb_log10,(hb_meanlog10 + (hb_sdlog10 * get_base1(sigma,1,"sigma",1))));
            T__ kd_log10;
            (void) kd_log10;  // dummy to suppress unused var warning

            stan::math::initialize(kd_log10, DUMMY_VAR__);
            stan::math::fill(kd_log10,DUMMY_VAR__);
            stan::math::assign(kd_log10,(kd_meanlog10 + (kd_sdlog10 * get_base1(sigma,2,"sigma",1))));
            T__ alpha_log10;
            (void) alpha_log10;  // dummy to suppress unused var warning

            stan::math::initialize(alpha_log10, DUMMY_VAR__);
            stan::math::fill(alpha_log10,DUMMY_VAR__);
            stan::math::assign(alpha_log10,(alpha_meanlog10 + (alpha_sdlog10 * get_base1(sigma,3,"sigma",1))));
            validate_non_negative_index("param", "1", 1);
            vector<T__> param(1);
            stan::math::initialize(param, DUMMY_VAR__);
            stan::math::fill(param,DUMMY_VAR__);
            validate_non_negative_index("y_hat", "n_data_Nsurv", n_data_Nsurv);
            validate_non_negative_index("y_hat", "1", 1);
            Eigen::Matrix<T__,Eigen::Dynamic,Eigen::Dynamic>  y_hat(static_cast<Eigen::VectorXd::Index>(n_data_Nsurv),static_cast<Eigen::VectorXd::Index>(1));
            (void) y_hat;  // dummy to suppress unused var warning

            stan::math::initialize(y_hat, DUMMY_VAR__);
            stan::math::fill(y_hat,DUMMY_VAR__);
            validate_non_negative_index("Psurv_hat", "n_data_Nsurv", n_data_Nsurv);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Psurv_hat(static_cast<Eigen::VectorXd::Index>(n_data_Nsurv));
            (void) Psurv_hat;  // dummy to suppress unused var warning

            stan::math::initialize(Psurv_hat, DUMMY_VAR__);
            stan::math::fill(Psurv_hat,DUMMY_VAR__);
            validate_non_negative_index("Conditional_Psurv_hat", "n_data_Nsurv", n_data_Nsurv);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Conditional_Psurv_hat(static_cast<Eigen::VectorXd::Index>(n_data_Nsurv));
            (void) Conditional_Psurv_hat;  // dummy to suppress unused var warning

            stan::math::initialize(Conditional_Psurv_hat, DUMMY_VAR__);
            stan::math::fill(Conditional_Psurv_hat,DUMMY_VAR__);
            T__ hb;
            (void) hb;  // dummy to suppress unused var warning

            stan::math::initialize(hb, DUMMY_VAR__);
            stan::math::fill(hb,DUMMY_VAR__);
            stan::math::assign(hb,pow(10,hb_log10));
            T__ alpha;
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, DUMMY_VAR__);
            stan::math::fill(alpha,DUMMY_VAR__);
            stan::math::assign(alpha,pow(10,alpha_log10));
            T__ beta;
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);
            stan::math::assign(beta,pow(10,beta_log10));


            stan::math::assign(get_base1_lhs(param,1,"param",1), pow(10,kd_log10));
            for (int gr = 1; gr <= n_group; ++gr) {

                stan::model::assign(y_hat, 
                            stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                            stan::model::rvalue(solve_TKTD_varIT(y0,0,stan::model::rvalue(tNsurv_ode, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "tNsurv_ode"),param,stan::model::rvalue(tconc_ode, stan::model::cons_list(stan::model::index_min_max(get_base1(idC_lw,gr,"idC_lw",1), get_base1(idC_up,gr,"idC_up",1)), stan::model::nil_index_list()), "tconc_ode"),stan::model::rvalue(conc, stan::model::cons_list(stan::model::index_min_max(get_base1(idC_lw,gr,"idC_lw",1), get_base1(idC_up,gr,"idC_up",1)), stan::model::nil_index_list()), "conc"),odeParam, pstream__), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "solve_TKTD_varIT(y0,0,tNsurv_ode[idS_lw[gr]:idS_up[gr]],param,tconc_ode[idC_lw[gr]:idC_up[gr]],conc[idC_lw[gr]:idC_up[gr]],odeParam, pstream__)"), 
                            "assigning variable y_hat");
                for (int i = get_base1(idS_lw,gr,"idS_lw",1); i <= get_base1(idS_up,gr,"idS_up",1); ++i) {

                    if (as_bool(logical_eq(proper_distribution,1))) {

                        stan::math::assign(get_base1_lhs(Psurv_hat,i,"Psurv_hat",1), (exp((-(hb) * get_base1(tNsurv_ode,i,"tNsurv_ode",1))) * (1 - exp(loglogistic_lcdf(max(stan::model::rvalue(y_hat, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), i), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "y_hat")),alpha,beta, pstream__)))));
                    }
                    if (as_bool(logical_eq(proper_distribution,2))) {

                        stan::math::assign(get_base1_lhs(Psurv_hat,i,"Psurv_hat",1), (exp((-(hb) * get_base1(tNsurv_ode,i,"tNsurv_ode",1))) * (1 - exp(lognormal_cdf_log(max(stan::model::rvalue(y_hat, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), i), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "y_hat")),alpha,beta)))));
                    }
                    stan::math::assign(get_base1_lhs(Conditional_Psurv_hat,i,"Conditional_Psurv_hat",1), (logical_eq(i,get_base1(idS_lw,gr,"idS_lw",1)) ? stan::math::promote_scalar<T__>(get_base1(Psurv_hat,i,"Psurv_hat",1)) : stan::math::promote_scalar<T__>((get_base1(Psurv_hat,i,"Psurv_hat",1) / get_base1(Psurv_hat,(i - 1),"Psurv_hat",1))) ));
                }
            }

            // validate transformed parameters
            if (stan::math::is_uninitialized(hb_log10)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: hb_log10";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(kd_log10)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: kd_log10";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(alpha_log10)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: alpha_log10";
                throw std::runtime_error(msg__.str());
            }
            for (int i0__ = 0; i0__ < 1; ++i0__) {
                if (stan::math::is_uninitialized(param[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: param" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < n_data_Nsurv; ++i0__) {
                for (int i1__ = 0; i1__ < 1; ++i1__) {
                    if (stan::math::is_uninitialized(y_hat(i0__,i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: y_hat" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < n_data_Nsurv; ++i0__) {
                if (stan::math::is_uninitialized(Psurv_hat(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Psurv_hat" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < n_data_Nsurv; ++i0__) {
                if (stan::math::is_uninitialized(Conditional_Psurv_hat(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Conditional_Psurv_hat" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            if (stan::math::is_uninitialized(hb)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: hb";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(alpha)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: alpha";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(beta)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: beta";
                throw std::runtime_error(msg__.str());
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            for (int k0__ = 0; k0__ < 1; ++k0__) {
                check_greater_or_equal(function__,"param[k0__]",param[k0__],0);
            }
            check_greater_or_equal(function__,"Psurv_hat",Psurv_hat,0);
            check_less_or_equal(function__,"Psurv_hat",Psurv_hat,1);
            check_greater_or_equal(function__,"Conditional_Psurv_hat",Conditional_Psurv_hat,0);
            check_less_or_equal(function__,"Conditional_Psurv_hat",Conditional_Psurv_hat,1);

            // model body

            lp_accum__.add(uniform_log(beta_log10,beta_minlog10,beta_maxlog10));
            lp_accum__.add(normal_log(sigma,0,1));
            for (int gr = 1; gr <= n_group; ++gr) {

                lp_accum__.add(binomial_log(stan::model::rvalue(Nsurv, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "Nsurv"),stan::model::rvalue(Nprec, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "Nprec"),stan::model::rvalue(Conditional_Psurv_hat, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "Conditional_Psurv_hat")));
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("beta_log10");
        names__.push_back("sigma");
        names__.push_back("hb_log10");
        names__.push_back("kd_log10");
        names__.push_back("alpha_log10");
        names__.push_back("param");
        names__.push_back("y_hat");
        names__.push_back("Psurv_hat");
        names__.push_back("Conditional_Psurv_hat");
        names__.push_back("hb");
        names__.push_back("alpha");
        names__.push_back("beta");
        names__.push_back("Nsurv_ppc");
        names__.push_back("Nsurv_sim");
        names__.push_back("Nsurv_sim_prec");
        names__.push_back("log_lik");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(1);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_data_Nsurv);
        dims__.push_back(1);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_data_Nsurv);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_data_Nsurv);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_data_Nsurv);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_data_Nsurv);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_data_Nsurv);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_data_Nsurv);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_ode_TKTD_varIT_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double beta_log10 = in__.scalar_constrain();
        vector<double> sigma;
        size_t dim_sigma_0__ = 3;
        for (size_t k_0__ = 0; k_0__ < dim_sigma_0__; ++k_0__) {
            sigma.push_back(in__.scalar_constrain());
        }
        vars__.push_back(beta_log10);
            for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            double hb_log10(0.0);
            (void) hb_log10;  // dummy to suppress unused var warning

            stan::math::initialize(hb_log10, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(hb_log10,DUMMY_VAR__);
            stan::math::assign(hb_log10,(hb_meanlog10 + (hb_sdlog10 * get_base1(sigma,1,"sigma",1))));
            double kd_log10(0.0);
            (void) kd_log10;  // dummy to suppress unused var warning

            stan::math::initialize(kd_log10, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(kd_log10,DUMMY_VAR__);
            stan::math::assign(kd_log10,(kd_meanlog10 + (kd_sdlog10 * get_base1(sigma,2,"sigma",1))));
            double alpha_log10(0.0);
            (void) alpha_log10;  // dummy to suppress unused var warning

            stan::math::initialize(alpha_log10, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha_log10,DUMMY_VAR__);
            stan::math::assign(alpha_log10,(alpha_meanlog10 + (alpha_sdlog10 * get_base1(sigma,3,"sigma",1))));
            validate_non_negative_index("param", "1", 1);
            vector<double> param(1, 0.0);
            stan::math::initialize(param, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(param,DUMMY_VAR__);
            validate_non_negative_index("y_hat", "n_data_Nsurv", n_data_Nsurv);
            validate_non_negative_index("y_hat", "1", 1);
            matrix_d y_hat(static_cast<Eigen::VectorXd::Index>(n_data_Nsurv),static_cast<Eigen::VectorXd::Index>(1));
            (void) y_hat;  // dummy to suppress unused var warning

            stan::math::initialize(y_hat, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_hat,DUMMY_VAR__);
            validate_non_negative_index("Psurv_hat", "n_data_Nsurv", n_data_Nsurv);
            vector_d Psurv_hat(static_cast<Eigen::VectorXd::Index>(n_data_Nsurv));
            (void) Psurv_hat;  // dummy to suppress unused var warning

            stan::math::initialize(Psurv_hat, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Psurv_hat,DUMMY_VAR__);
            validate_non_negative_index("Conditional_Psurv_hat", "n_data_Nsurv", n_data_Nsurv);
            vector_d Conditional_Psurv_hat(static_cast<Eigen::VectorXd::Index>(n_data_Nsurv));
            (void) Conditional_Psurv_hat;  // dummy to suppress unused var warning

            stan::math::initialize(Conditional_Psurv_hat, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Conditional_Psurv_hat,DUMMY_VAR__);
            double hb(0.0);
            (void) hb;  // dummy to suppress unused var warning

            stan::math::initialize(hb, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(hb,DUMMY_VAR__);
            stan::math::assign(hb,pow(10,hb_log10));
            double alpha(0.0);
            (void) alpha;  // dummy to suppress unused var warning

            stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha,DUMMY_VAR__);
            stan::math::assign(alpha,pow(10,alpha_log10));
            double beta(0.0);
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);
            stan::math::assign(beta,pow(10,beta_log10));


            stan::math::assign(get_base1_lhs(param,1,"param",1), pow(10,kd_log10));
            for (int gr = 1; gr <= n_group; ++gr) {

                stan::model::assign(y_hat, 
                            stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                            stan::model::rvalue(solve_TKTD_varIT(y0,0,stan::model::rvalue(tNsurv_ode, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "tNsurv_ode"),param,stan::model::rvalue(tconc_ode, stan::model::cons_list(stan::model::index_min_max(get_base1(idC_lw,gr,"idC_lw",1), get_base1(idC_up,gr,"idC_up",1)), stan::model::nil_index_list()), "tconc_ode"),stan::model::rvalue(conc, stan::model::cons_list(stan::model::index_min_max(get_base1(idC_lw,gr,"idC_lw",1), get_base1(idC_up,gr,"idC_up",1)), stan::model::nil_index_list()), "conc"),odeParam, pstream__), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "solve_TKTD_varIT(y0,0,tNsurv_ode[idS_lw[gr]:idS_up[gr]],param,tconc_ode[idC_lw[gr]:idC_up[gr]],conc[idC_lw[gr]:idC_up[gr]],odeParam, pstream__)"), 
                            "assigning variable y_hat");
                for (int i = get_base1(idS_lw,gr,"idS_lw",1); i <= get_base1(idS_up,gr,"idS_up",1); ++i) {

                    if (as_bool(logical_eq(proper_distribution,1))) {

                        stan::math::assign(get_base1_lhs(Psurv_hat,i,"Psurv_hat",1), (exp((-(hb) * get_base1(tNsurv_ode,i,"tNsurv_ode",1))) * (1 - exp(loglogistic_lcdf(max(stan::model::rvalue(y_hat, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), i), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "y_hat")),alpha,beta, pstream__)))));
                    }
                    if (as_bool(logical_eq(proper_distribution,2))) {

                        stan::math::assign(get_base1_lhs(Psurv_hat,i,"Psurv_hat",1), (exp((-(hb) * get_base1(tNsurv_ode,i,"tNsurv_ode",1))) * (1 - exp(lognormal_cdf_log(max(stan::model::rvalue(y_hat, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), i), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "y_hat")),alpha,beta)))));
                    }
                    stan::math::assign(get_base1_lhs(Conditional_Psurv_hat,i,"Conditional_Psurv_hat",1), (logical_eq(i,get_base1(idS_lw,gr,"idS_lw",1)) ? stan::math::promote_scalar<double>(get_base1(Psurv_hat,i,"Psurv_hat",1)) : stan::math::promote_scalar<double>((get_base1(Psurv_hat,i,"Psurv_hat",1) / get_base1(Psurv_hat,(i - 1),"Psurv_hat",1))) ));
                }
            }

            // validate transformed parameters
            for (int k0__ = 0; k0__ < 1; ++k0__) {
                check_greater_or_equal(function__,"param[k0__]",param[k0__],0);
            }
            check_greater_or_equal(function__,"Psurv_hat",Psurv_hat,0);
            check_less_or_equal(function__,"Psurv_hat",Psurv_hat,1);
            check_greater_or_equal(function__,"Conditional_Psurv_hat",Conditional_Psurv_hat,0);
            check_less_or_equal(function__,"Conditional_Psurv_hat",Conditional_Psurv_hat,1);

            // write transformed parameters
        vars__.push_back(hb_log10);
        vars__.push_back(kd_log10);
        vars__.push_back(alpha_log10);
            for (int k_0__ = 0; k_0__ < 1; ++k_0__) {
            vars__.push_back(param[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < 1; ++k_1__) {
                for (int k_0__ = 0; k_0__ < n_data_Nsurv; ++k_0__) {
                vars__.push_back(y_hat(k_0__, k_1__));
                }
            }
            for (int k_0__ = 0; k_0__ < n_data_Nsurv; ++k_0__) {
            vars__.push_back(Psurv_hat[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < n_data_Nsurv; ++k_0__) {
            vars__.push_back(Conditional_Psurv_hat[k_0__]);
            }
        vars__.push_back(hb);
        vars__.push_back(alpha);
        vars__.push_back(beta);

            if (!include_gqs__) return;
            // declare and define generated quantities
            validate_non_negative_index("Nsurv_ppc", "n_data_Nsurv", n_data_Nsurv);
            vector<int> Nsurv_ppc(n_data_Nsurv, 0);
            stan::math::fill(Nsurv_ppc, std::numeric_limits<int>::min());
            validate_non_negative_index("Nsurv_sim", "n_data_Nsurv", n_data_Nsurv);
            vector<int> Nsurv_sim(n_data_Nsurv, 0);
            stan::math::fill(Nsurv_sim, std::numeric_limits<int>::min());
            validate_non_negative_index("Nsurv_sim_prec", "n_data_Nsurv", n_data_Nsurv);
            vector<int> Nsurv_sim_prec(n_data_Nsurv, 0);
            stan::math::fill(Nsurv_sim_prec, std::numeric_limits<int>::min());
            validate_non_negative_index("log_lik", "n_data_Nsurv", n_data_Nsurv);
            vector_d log_lik(static_cast<Eigen::VectorXd::Index>(n_data_Nsurv));
            (void) log_lik;  // dummy to suppress unused var warning

            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);


            for (int gr = 1; gr <= n_group; ++gr) {

                for (int i = get_base1(idS_lw,gr,"idS_lw",1); i <= get_base1(idS_up,gr,"idS_up",1); ++i) {

                    stan::math::assign(get_base1_lhs(Nsurv_ppc,i,"Nsurv_ppc",1), binomial_rng(get_base1(Nprec,i,"Nprec",1),get_base1(Conditional_Psurv_hat,i,"Conditional_Psurv_hat",1), base_rng__));
                    stan::math::assign(get_base1_lhs(Nsurv_sim_prec,i,"Nsurv_sim_prec",1), (logical_eq(i,get_base1(idS_lw,gr,"idS_lw",1)) ? get_base1(Nprec,i,"Nprec",1) : get_base1(Nsurv_sim,(i - 1),"Nsurv_sim",1) ));
                    stan::math::assign(get_base1_lhs(Nsurv_sim,i,"Nsurv_sim",1), binomial_rng(get_base1(Nsurv_sim_prec,i,"Nsurv_sim_prec",1),get_base1(Conditional_Psurv_hat,i,"Conditional_Psurv_hat",1), base_rng__));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), binomial_log(stan::model::rvalue(Nsurv, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "Nsurv"),stan::model::rvalue(Nprec, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "Nprec"),stan::model::rvalue(Conditional_Psurv_hat, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "Conditional_Psurv_hat")));
                }
            }

            // validate generated quantities

            // write generated quantities
            for (int k_0__ = 0; k_0__ < n_data_Nsurv; ++k_0__) {
            vars__.push_back(Nsurv_ppc[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < n_data_Nsurv; ++k_0__) {
            vars__.push_back(Nsurv_sim[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < n_data_Nsurv; ++k_0__) {
            vars__.push_back(Nsurv_sim_prec[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < n_data_Nsurv; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_ode_TKTD_varIT";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta_log10";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "hb_log10";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "kd_log10";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "alpha_log10";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= 1; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "param" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= 1; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_hat" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Psurv_hat" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Conditional_Psurv_hat" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "hb";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Nsurv_ppc" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Nsurv_sim" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Nsurv_sim_prec" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta_log10";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "hb_log10";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "kd_log10";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "alpha_log10";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= 1; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "param" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= 1; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_hat" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Psurv_hat" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Conditional_Psurv_hat" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "hb";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Nsurv_ppc" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Nsurv_sim" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Nsurv_sim_prec" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_ode_TKTD_varPROPER_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_ode_TKTD_varPROPER");
    reader.add_event(275, 275, "end", "model_ode_TKTD_varPROPER");
    return reader;
}

template <typename T0__, typename T1__>
int
find_interval_elem(const T0__& x,
                       const Eigen::Matrix<T1__, Eigen::Dynamic,1>& sorted,
                       const int& start_ind, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        int res(0);
        (void) res;  // dummy to suppress unused var warning

        stan::math::fill(res, std::numeric_limits<int>::min());
        int N(0);
        (void) N;  // dummy to suppress unused var warning

        stan::math::fill(N, std::numeric_limits<int>::min());
        int max_iter(0);
        (void) max_iter;  // dummy to suppress unused var warning

        stan::math::fill(max_iter, std::numeric_limits<int>::min());
        fun_scalar_t__ left;
        (void) left;  // dummy to suppress unused var warning

        stan::math::initialize(left, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(left,DUMMY_VAR__);
        fun_scalar_t__ right;
        (void) right;  // dummy to suppress unused var warning

        stan::math::initialize(right, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(right,DUMMY_VAR__);
        int left_ind(0);
        (void) left_ind;  // dummy to suppress unused var warning

        stan::math::fill(left_ind, std::numeric_limits<int>::min());
        int right_ind(0);
        (void) right_ind;  // dummy to suppress unused var warning

        stan::math::fill(right_ind, std::numeric_limits<int>::min());
        int iter(0);
        (void) iter;  // dummy to suppress unused var warning

        stan::math::fill(iter, std::numeric_limits<int>::min());


        stan::math::assign(N, num_elements(sorted));
        if (as_bool(logical_eq(N,0))) {
            return stan::math::promote_scalar<fun_return_scalar_t__>(0);
        }
        stan::math::assign(left_ind, start_ind);
        stan::math::assign(right_ind, N);
        stan::math::assign(max_iter, (100 * N));
        stan::math::assign(left, (get_base1(sorted,left_ind,"sorted",1) - x));
        stan::math::assign(right, (get_base1(sorted,right_ind,"sorted",1) - x));
        if (as_bool(logical_lte(0,left))) {
            return stan::math::promote_scalar<fun_return_scalar_t__>((left_ind - 1));
        }
        if (as_bool(logical_eq(0,right))) {
            return stan::math::promote_scalar<fun_return_scalar_t__>((N - 1));
        }
        if (as_bool(logical_gt(0,right))) {
            return stan::math::promote_scalar<fun_return_scalar_t__>(N);
        }
        stan::math::assign(iter, 1);
        while (as_bool((primitive_value(logical_gt((right_ind - left_ind),1)) && primitive_value(logical_neq(iter,max_iter))))) {
            {
            int mid_ind(0);
            (void) mid_ind;  // dummy to suppress unused var warning

            stan::math::fill(mid_ind, std::numeric_limits<int>::min());
            fun_scalar_t__ mid;
            (void) mid;  // dummy to suppress unused var warning

            stan::math::initialize(mid, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mid,DUMMY_VAR__);


            stan::math::assign(mid_ind, divide((left_ind + right_ind),2));
            stan::math::assign(mid, (get_base1(sorted,mid_ind,"sorted",1) - x));
            if (as_bool(logical_eq(mid,0))) {
                return stan::math::promote_scalar<fun_return_scalar_t__>((mid_ind - 1));
            }
            if (as_bool(logical_lt((left * mid),0))) {

                stan::math::assign(right, mid);
                stan::math::assign(right_ind, mid_ind);
            }
            if (as_bool(logical_lt((right * mid),0))) {

                stan::math::assign(left, mid);
                stan::math::assign(left_ind, mid_ind);
            }
            stan::math::assign(iter, (iter + 1));
            }
        }
        if (as_bool(logical_eq(iter,max_iter))) {
            if (pstream__) {
                stan_print(pstream__,"Maximum number of iterations reached.");
                *pstream__ << std::endl;
            }
        }
        return stan::math::promote_scalar<fun_return_scalar_t__>(left_ind);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct find_interval_elem_functor__ {
    template <typename T0__, typename T1__>
        int
    operator()(const T0__& x,
                       const Eigen::Matrix<T1__, Eigen::Dynamic,1>& sorted,
                       const int& start_ind, std::ostream* pstream__) const {
        return find_interval_elem(x, sorted, start_ind, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
linearInterp(const T0__& t_x,
                 const T1__& t_before,
                 const T2__& t_after,
                 const T3__& y_before,
                 const T4__& y_after, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        fun_scalar_t__ linInterp_hat;
        (void) linInterp_hat;  // dummy to suppress unused var warning

        stan::math::initialize(linInterp_hat, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(linInterp_hat,DUMMY_VAR__);


        stan::math::assign(linInterp_hat, (y_before + (((t_x - t_before) * (y_after - y_before)) / (t_after - t_before))));
        return stan::math::promote_scalar<fun_return_scalar_t__>(linInterp_hat);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct linearInterp_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& t_x,
                 const T1__& t_before,
                 const T2__& t_after,
                 const T3__& y_before,
                 const T4__& y_after, std::ostream* pstream__) const {
        return linearInterp(t_x, t_before, t_after, y_before, y_after, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
loglogistic_lpdf(const T0__& y_hat,
                     const T1__& alpha,
                     const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        return stan::math::promote_scalar<fun_return_scalar_t__>((((log(beta) - log(alpha)) + ((beta - 1) * (log(y_hat) - log(alpha)))) - (2 * log1p_exp((beta * (log(y_hat) - log(alpha)))))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
loglogistic_lpdf(const T0__& y_hat,
                     const T1__& alpha,
                     const T2__& beta, std::ostream* pstream__) {
    return loglogistic_lpdf<false>(y_hat,alpha,beta, pstream__);
}


struct loglogistic_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y_hat,
                     const T1__& alpha,
                     const T2__& beta, std::ostream* pstream__) const {
        return loglogistic_lpdf(y_hat, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
loglogistic_lcdf(const T0__& y_hat,
                     const T1__& alpha,
                     const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        return stan::math::promote_scalar<fun_return_scalar_t__>(-(log1p_exp((-(beta) * (log(y_hat) - log(alpha))))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct loglogistic_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y_hat,
                     const T1__& alpha,
                     const T2__& beta, std::ostream* pstream__) const {
        return loglogistic_lcdf(y_hat, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
loglogistic_lccdf(const T0__& y_hat,
                      const T1__& alpha,
                      const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        return stan::math::promote_scalar<fun_return_scalar_t__>(-(log1p_exp((beta * (log(y_hat) - log(alpha))))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct loglogistic_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y_hat,
                      const T1__& alpha,
                      const T2__& beta, std::ostream* pstream__) const {
        return loglogistic_lccdf(y_hat, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
std::vector<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type>
TKTD_varPROPER(const T0__& t,
                   const std::vector<T1__>& y,
                   const std::vector<T2__>& theta,
                   const std::vector<T3__>& x_r,
                   const std::vector<int>& x_i, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        fun_scalar_t__ hb;
        (void) hb;  // dummy to suppress unused var warning

        stan::math::initialize(hb, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(hb,DUMMY_VAR__);
        stan::math::assign(hb,get_base1(theta,1,"theta",1));
        fun_scalar_t__ kd;
        (void) kd;  // dummy to suppress unused var warning

        stan::math::initialize(kd, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(kd,DUMMY_VAR__);
        stan::math::assign(kd,get_base1(theta,2,"theta",1));
        fun_scalar_t__ z;
        (void) z;  // dummy to suppress unused var warning

        stan::math::initialize(z, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(z,DUMMY_VAR__);
        stan::math::assign(z,get_base1(theta,3,"theta",1));
        fun_scalar_t__ kk;
        (void) kk;  // dummy to suppress unused var warning

        stan::math::initialize(kk, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(kk,DUMMY_VAR__);
        stan::math::assign(kk,get_base1(theta,4,"theta",1));
        validate_non_negative_index("max_z", "2", 2);
        vector<fun_scalar_t__> max_z(2);
        stan::math::initialize(max_z, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(max_z,DUMMY_VAR__);
        validate_non_negative_index("dy_dt", "2", 2);
        vector<fun_scalar_t__> dy_dt(2);
        stan::math::initialize(dy_dt, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(dy_dt,DUMMY_VAR__);
        int Nconc(0);
        (void) Nconc;  // dummy to suppress unused var warning

        stan::math::fill(Nconc, std::numeric_limits<int>::min());
        stan::math::assign(Nconc,get_base1(x_i,1,"x_i",1));
        validate_non_negative_index("tconc", "Nconc", Nconc);
        Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  tconc(static_cast<Eigen::VectorXd::Index>(Nconc));
        (void) tconc;  // dummy to suppress unused var warning

        stan::math::initialize(tconc, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(tconc,DUMMY_VAR__);
        stan::math::assign(tconc,to_vector(stan::model::rvalue(x_r, stan::model::cons_list(stan::model::index_min_max(1, Nconc), stan::model::nil_index_list()), "x_r")));
        validate_non_negative_index("conc", "Nconc", Nconc);
        Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  conc(static_cast<Eigen::VectorXd::Index>(Nconc));
        (void) conc;  // dummy to suppress unused var warning

        stan::math::initialize(conc, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(conc,DUMMY_VAR__);
        stan::math::assign(conc,to_vector(stan::model::rvalue(x_r, stan::model::cons_list(stan::model::index_min_max((Nconc + 1), (2 * Nconc)), stan::model::nil_index_list()), "x_r")));
        int pulse_index(0);
        (void) pulse_index;  // dummy to suppress unused var warning

        stan::math::fill(pulse_index, std::numeric_limits<int>::min());
        stan::math::assign(pulse_index,find_interval_elem(t,tconc,1, pstream__));
        fun_scalar_t__ conc_linInterp;
        (void) conc_linInterp;  // dummy to suppress unused var warning

        stan::math::initialize(conc_linInterp, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(conc_linInterp,DUMMY_VAR__);
        stan::math::assign(conc_linInterp,(logical_neq(pulse_index,0) ? stan::math::promote_scalar<fun_scalar_t__>(linearInterp(t,get_base1(tconc,pulse_index,"tconc",1),get_base1(tconc,(pulse_index + 1),"tconc",1),get_base1(conc,pulse_index,"conc",1),get_base1(conc,(pulse_index + 1),"conc",1), pstream__)) : stan::math::promote_scalar<fun_scalar_t__>(get_base1(conc,1,"conc",1)) ));


        stan::math::assign(get_base1_lhs(dy_dt,1,"dy_dt",1), (kd * (conc_linInterp - get_base1(y,1,"y",1))));
        stan::math::assign(get_base1_lhs(max_z,1,"max_z",1), 0);
        stan::math::assign(get_base1_lhs(max_z,2,"max_z",1), (get_base1(y,1,"y",1) - z));
        stan::math::assign(get_base1_lhs(dy_dt,2,"dy_dt",1), ((kk * max(max_z)) + hb));
        return stan::math::promote_scalar<fun_return_scalar_t__>(dy_dt);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct TKTD_varPROPER_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        std::vector<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type>
    operator()(const T0__& t,
                   const std::vector<T1__>& y,
                   const std::vector<T2__>& theta,
                   const std::vector<T3__>& x_r,
                   const std::vector<int>& x_i, std::ostream* pstream__) const {
        return TKTD_varPROPER(t, y, theta, x_r, x_i, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
solve_TKTD_varPROPER(const std::vector<T0__>& y0,
                         const T1__& t0,
                         const std::vector<T2__>& ts,
                         const std::vector<T3__>& theta,
                         const std::vector<T4__>& tconc,
                         const std::vector<T5__>& conc,
                         const std::vector<T6__>& odeParam, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        validate_non_negative_index("x_i", "1", 1);
        vector<int> x_i(1, 0);
        stan::math::fill(x_i, std::numeric_limits<int>::min());


        stan::math::assign(get_base1_lhs(x_i,1,"x_i",1), size(tconc));
        return stan::math::promote_scalar<fun_return_scalar_t__>(to_matrix(integrate_ode_rk45(TKTD_varPROPER_functor__(), y0, t0, ts, theta, to_array_1d(append_row(to_vector(tconc),to_vector(conc))), x_i, pstream__, get_base1(odeParam,1,"odeParam",1), get_base1(odeParam,2,"odeParam",1), get_base1(odeParam,3,"odeParam",1))));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct solve_TKTD_varPROPER_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const std::vector<T0__>& y0,
                         const T1__& t0,
                         const std::vector<T2__>& ts,
                         const std::vector<T3__>& theta,
                         const std::vector<T4__>& tconc,
                         const std::vector<T5__>& conc,
                         const std::vector<T6__>& odeParam, std::ostream* pstream__) const {
        return solve_TKTD_varPROPER(y0, t0, ts, theta, tconc, conc, odeParam, pstream__);
    }
};

class model_ode_TKTD_varPROPER : public prob_grad {
private:
    int n_group;
    int n_data_conc;
    vector<double> conc;
    vector<double> tconc;
    vector<int> idC_lw;
    vector<int> idC_up;
    int n_data_Nsurv;
    vector<int> Nsurv;
    vector<int> Nprec;
    vector<double> tNsurv;
    vector<int> idS_lw;
    vector<int> idS_up;
    double hb_meanlog10;
    double hb_sdlog10;
    double kd_meanlog10;
    double kd_sdlog10;
    double rel_tol;
    double abs_tol;
    int max_num_steps;
    int proper_distribution;
    double kk_meanlog10;
    double kk_sdlog10;
    double alpha_meanlog10;
    double alpha_sdlog10;
    double beta_minlog10;
    double beta_maxlog10;
    vector<double> y0;
    vector<double> odeParam;
    vector<double> tNsurv_ode;
    vector<double> tconc_ode;
public:
    model_ode_TKTD_varPROPER(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_ode_TKTD_varPROPER(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_ode_TKTD_varPROPER_namespace::model_ode_TKTD_varPROPER";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "n_group", "int", context__.to_vec());
            n_group = int(0);
            vals_i__ = context__.vals_i("n_group");
            pos__ = 0;
            n_group = vals_i__[pos__++];
            context__.validate_dims("data initialization", "n_data_conc", "int", context__.to_vec());
            n_data_conc = int(0);
            vals_i__ = context__.vals_i("n_data_conc");
            pos__ = 0;
            n_data_conc = vals_i__[pos__++];
            validate_non_negative_index("conc", "n_data_conc", n_data_conc);
            context__.validate_dims("data initialization", "conc", "double", context__.to_vec(n_data_conc));
            validate_non_negative_index("conc", "n_data_conc", n_data_conc);
            conc = std::vector<double>(n_data_conc,double(0));
            vals_r__ = context__.vals_r("conc");
            pos__ = 0;
            size_t conc_limit_0__ = n_data_conc;
            for (size_t i_0__ = 0; i_0__ < conc_limit_0__; ++i_0__) {
                conc[i_0__] = vals_r__[pos__++];
            }
            validate_non_negative_index("tconc", "n_data_conc", n_data_conc);
            context__.validate_dims("data initialization", "tconc", "double", context__.to_vec(n_data_conc));
            validate_non_negative_index("tconc", "n_data_conc", n_data_conc);
            tconc = std::vector<double>(n_data_conc,double(0));
            vals_r__ = context__.vals_r("tconc");
            pos__ = 0;
            size_t tconc_limit_0__ = n_data_conc;
            for (size_t i_0__ = 0; i_0__ < tconc_limit_0__; ++i_0__) {
                tconc[i_0__] = vals_r__[pos__++];
            }
            validate_non_negative_index("idC_lw", "n_group", n_group);
            context__.validate_dims("data initialization", "idC_lw", "int", context__.to_vec(n_group));
            validate_non_negative_index("idC_lw", "n_group", n_group);
            idC_lw = std::vector<int>(n_group,int(0));
            vals_i__ = context__.vals_i("idC_lw");
            pos__ = 0;
            size_t idC_lw_limit_0__ = n_group;
            for (size_t i_0__ = 0; i_0__ < idC_lw_limit_0__; ++i_0__) {
                idC_lw[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("idC_up", "n_group", n_group);
            context__.validate_dims("data initialization", "idC_up", "int", context__.to_vec(n_group));
            validate_non_negative_index("idC_up", "n_group", n_group);
            idC_up = std::vector<int>(n_group,int(0));
            vals_i__ = context__.vals_i("idC_up");
            pos__ = 0;
            size_t idC_up_limit_0__ = n_group;
            for (size_t i_0__ = 0; i_0__ < idC_up_limit_0__; ++i_0__) {
                idC_up[i_0__] = vals_i__[pos__++];
            }
            context__.validate_dims("data initialization", "n_data_Nsurv", "int", context__.to_vec());
            n_data_Nsurv = int(0);
            vals_i__ = context__.vals_i("n_data_Nsurv");
            pos__ = 0;
            n_data_Nsurv = vals_i__[pos__++];
            validate_non_negative_index("Nsurv", "n_data_Nsurv", n_data_Nsurv);
            context__.validate_dims("data initialization", "Nsurv", "int", context__.to_vec(n_data_Nsurv));
            validate_non_negative_index("Nsurv", "n_data_Nsurv", n_data_Nsurv);
            Nsurv = std::vector<int>(n_data_Nsurv,int(0));
            vals_i__ = context__.vals_i("Nsurv");
            pos__ = 0;
            size_t Nsurv_limit_0__ = n_data_Nsurv;
            for (size_t i_0__ = 0; i_0__ < Nsurv_limit_0__; ++i_0__) {
                Nsurv[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("Nprec", "n_data_Nsurv", n_data_Nsurv);
            context__.validate_dims("data initialization", "Nprec", "int", context__.to_vec(n_data_Nsurv));
            validate_non_negative_index("Nprec", "n_data_Nsurv", n_data_Nsurv);
            Nprec = std::vector<int>(n_data_Nsurv,int(0));
            vals_i__ = context__.vals_i("Nprec");
            pos__ = 0;
            size_t Nprec_limit_0__ = n_data_Nsurv;
            for (size_t i_0__ = 0; i_0__ < Nprec_limit_0__; ++i_0__) {
                Nprec[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("tNsurv", "n_data_Nsurv", n_data_Nsurv);
            context__.validate_dims("data initialization", "tNsurv", "double", context__.to_vec(n_data_Nsurv));
            validate_non_negative_index("tNsurv", "n_data_Nsurv", n_data_Nsurv);
            tNsurv = std::vector<double>(n_data_Nsurv,double(0));
            vals_r__ = context__.vals_r("tNsurv");
            pos__ = 0;
            size_t tNsurv_limit_0__ = n_data_Nsurv;
            for (size_t i_0__ = 0; i_0__ < tNsurv_limit_0__; ++i_0__) {
                tNsurv[i_0__] = vals_r__[pos__++];
            }
            validate_non_negative_index("idS_lw", "n_group", n_group);
            context__.validate_dims("data initialization", "idS_lw", "int", context__.to_vec(n_group));
            validate_non_negative_index("idS_lw", "n_group", n_group);
            idS_lw = std::vector<int>(n_group,int(0));
            vals_i__ = context__.vals_i("idS_lw");
            pos__ = 0;
            size_t idS_lw_limit_0__ = n_group;
            for (size_t i_0__ = 0; i_0__ < idS_lw_limit_0__; ++i_0__) {
                idS_lw[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("idS_up", "n_group", n_group);
            context__.validate_dims("data initialization", "idS_up", "int", context__.to_vec(n_group));
            validate_non_negative_index("idS_up", "n_group", n_group);
            idS_up = std::vector<int>(n_group,int(0));
            vals_i__ = context__.vals_i("idS_up");
            pos__ = 0;
            size_t idS_up_limit_0__ = n_group;
            for (size_t i_0__ = 0; i_0__ < idS_up_limit_0__; ++i_0__) {
                idS_up[i_0__] = vals_i__[pos__++];
            }
            context__.validate_dims("data initialization", "hb_meanlog10", "double", context__.to_vec());
            hb_meanlog10 = double(0);
            vals_r__ = context__.vals_r("hb_meanlog10");
            pos__ = 0;
            hb_meanlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "hb_sdlog10", "double", context__.to_vec());
            hb_sdlog10 = double(0);
            vals_r__ = context__.vals_r("hb_sdlog10");
            pos__ = 0;
            hb_sdlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "kd_meanlog10", "double", context__.to_vec());
            kd_meanlog10 = double(0);
            vals_r__ = context__.vals_r("kd_meanlog10");
            pos__ = 0;
            kd_meanlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "kd_sdlog10", "double", context__.to_vec());
            kd_sdlog10 = double(0);
            vals_r__ = context__.vals_r("kd_sdlog10");
            pos__ = 0;
            kd_sdlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "rel_tol", "double", context__.to_vec());
            rel_tol = double(0);
            vals_r__ = context__.vals_r("rel_tol");
            pos__ = 0;
            rel_tol = vals_r__[pos__++];
            context__.validate_dims("data initialization", "abs_tol", "double", context__.to_vec());
            abs_tol = double(0);
            vals_r__ = context__.vals_r("abs_tol");
            pos__ = 0;
            abs_tol = vals_r__[pos__++];
            context__.validate_dims("data initialization", "max_num_steps", "int", context__.to_vec());
            max_num_steps = int(0);
            vals_i__ = context__.vals_i("max_num_steps");
            pos__ = 0;
            max_num_steps = vals_i__[pos__++];
            context__.validate_dims("data initialization", "proper_distribution", "int", context__.to_vec());
            proper_distribution = int(0);
            vals_i__ = context__.vals_i("proper_distribution");
            pos__ = 0;
            proper_distribution = vals_i__[pos__++];
            context__.validate_dims("data initialization", "kk_meanlog10", "double", context__.to_vec());
            kk_meanlog10 = double(0);
            vals_r__ = context__.vals_r("kk_meanlog10");
            pos__ = 0;
            kk_meanlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "kk_sdlog10", "double", context__.to_vec());
            kk_sdlog10 = double(0);
            vals_r__ = context__.vals_r("kk_sdlog10");
            pos__ = 0;
            kk_sdlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "alpha_meanlog10", "double", context__.to_vec());
            alpha_meanlog10 = double(0);
            vals_r__ = context__.vals_r("alpha_meanlog10");
            pos__ = 0;
            alpha_meanlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "alpha_sdlog10", "double", context__.to_vec());
            alpha_sdlog10 = double(0);
            vals_r__ = context__.vals_r("alpha_sdlog10");
            pos__ = 0;
            alpha_sdlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "beta_minlog10", "double", context__.to_vec());
            beta_minlog10 = double(0);
            vals_r__ = context__.vals_r("beta_minlog10");
            pos__ = 0;
            beta_minlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "beta_maxlog10", "double", context__.to_vec());
            beta_maxlog10 = double(0);
            vals_r__ = context__.vals_r("beta_maxlog10");
            pos__ = 0;
            beta_maxlog10 = vals_r__[pos__++];

            // validate, data variables
            check_greater_or_equal(function__,"n_group",n_group,1);
            check_greater_or_equal(function__,"n_data_conc",n_data_conc,1);
            for (int k0__ = 0; k0__ < n_group; ++k0__) {
                check_greater_or_equal(function__,"idC_lw[k0__]",idC_lw[k0__],1);
            }
            for (int k0__ = 0; k0__ < n_group; ++k0__) {
                check_greater_or_equal(function__,"idC_up[k0__]",idC_up[k0__],1);
            }
            check_greater_or_equal(function__,"n_data_Nsurv",n_data_Nsurv,1);
            for (int k0__ = 0; k0__ < n_group; ++k0__) {
                check_greater_or_equal(function__,"idS_lw[k0__]",idS_lw[k0__],1);
            }
            for (int k0__ = 0; k0__ < n_group; ++k0__) {
                check_greater_or_equal(function__,"idS_up[k0__]",idS_up[k0__],1);
            }
            // initialize data variables
            validate_non_negative_index("y0", "2", 2);
            y0 = std::vector<double>(2,double(0));
            stan::math::fill(y0,DUMMY_VAR__);
            validate_non_negative_index("odeParam", "3", 3);
            odeParam = std::vector<double>(3,double(0));
            stan::math::fill(odeParam,DUMMY_VAR__);
            validate_non_negative_index("tNsurv_ode", "n_data_Nsurv", n_data_Nsurv);
            tNsurv_ode = std::vector<double>(n_data_Nsurv,double(0));
            stan::math::fill(tNsurv_ode,DUMMY_VAR__);
            validate_non_negative_index("tconc_ode", "n_data_conc", n_data_conc);
            tconc_ode = std::vector<double>(n_data_conc,double(0));
            stan::math::fill(tconc_ode,DUMMY_VAR__);

            stan::math::assign(get_base1_lhs(y0,1,"y0",1), 0);
            stan::math::assign(get_base1_lhs(y0,2,"y0",1), 0);
            stan::math::assign(get_base1_lhs(odeParam,1,"odeParam",1), rel_tol);
            stan::math::assign(get_base1_lhs(odeParam,2,"odeParam",1), abs_tol);
            stan::math::assign(get_base1_lhs(odeParam,3,"odeParam",1), max_num_steps);
            for (int gr = 1; gr <= n_group; ++gr) {

                stan::model::assign(tNsurv_ode, 
                            stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), 
                            stan::model::rvalue(tNsurv, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "tNsurv"), 
                            "assigning variable tNsurv_ode");
                stan::math::assign(get_base1_lhs(tNsurv_ode,get_base1(idS_lw,gr,"idS_lw",1),"tNsurv_ode",1), (get_base1(tNsurv,get_base1(idS_lw,gr,"idS_lw",1),"tNsurv",1) + 1.0000000000000001e-09));
                stan::model::assign(tconc_ode, 
                            stan::model::cons_list(stan::model::index_min_max(get_base1(idC_lw,gr,"idC_lw",1), get_base1(idC_up,gr,"idC_up",1)), stan::model::nil_index_list()), 
                            stan::model::rvalue(tconc, stan::model::cons_list(stan::model::index_min_max(get_base1(idC_lw,gr,"idC_lw",1), get_base1(idC_up,gr,"idC_up",1)), stan::model::nil_index_list()), "tconc"), 
                            "assigning variable tconc_ode");
                stan::math::assign(get_base1_lhs(tconc_ode,get_base1(idC_lw,gr,"idC_lw",1),"tconc_ode",1), (get_base1(tconc,get_base1(idC_lw,gr,"idC_lw",1),"tconc",1) + 1.0000000000000001e-09));
            }

            // validate transformed data
            for (int k0__ = 0; k0__ < 2; ++k0__) {
                check_greater_or_equal(function__,"y0[k0__]",y0[k0__],0);
            }

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("sigma", "4", 4);
            num_params_r__ += 4;
            ++num_params_r__;
            ++num_params_r__;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_ode_TKTD_varPROPER() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "4", 4);
        context__.validate_dims("initialization", "sigma", "double", context__.to_vec(4));
        std::vector<double> sigma(4,double(0));
        for (int i0__ = 0U; i0__ < 4; ++i0__)
            sigma[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < 4; ++i0__)
            try {
            writer__.scalar_unconstrain(sigma[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("beta_log10")))
            throw std::runtime_error("variable beta_log10 missing");
        vals_r__ = context__.vals_r("beta_log10");
        pos__ = 0U;
        context__.validate_dims("initialization", "beta_log10", "double", context__.to_vec());
        double beta_log10(0);
        beta_log10 = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(beta_log10);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_log10: ") + e.what());
        }

        if (!(context__.contains_r("z")))
            throw std::runtime_error("variable z missing");
        vals_r__ = context__.vals_r("z");
        pos__ = 0U;
        context__.validate_dims("initialization", "z", "double", context__.to_vec());
        double z(0);
        z = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(z);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable z: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            vector<T__> sigma;
            size_t dim_sigma_0__ = 4;
            sigma.reserve(dim_sigma_0__);
            for (size_t k_0__ = 0; k_0__ < dim_sigma_0__; ++k_0__) {
                if (jacobian__)
                    sigma.push_back(in__.scalar_constrain(lp__));
                else
                    sigma.push_back(in__.scalar_constrain());
            }

            T__ beta_log10;
            (void) beta_log10;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_log10 = in__.scalar_constrain(lp__);
            else
                beta_log10 = in__.scalar_constrain();

            T__ z;
            (void) z;  // dummy to suppress unused var warning
            if (jacobian__)
                z = in__.scalar_constrain(lp__);
            else
                z = in__.scalar_constrain();


            // transformed parameters
            T__ hb_log10;
            (void) hb_log10;  // dummy to suppress unused var warning

            stan::math::initialize(hb_log10, DUMMY_VAR__);
            stan::math::fill(hb_log10,DUMMY_VAR__);
            stan::math::assign(hb_log10,(hb_meanlog10 + (hb_sdlog10 * get_base1(sigma,1,"sigma",1))));
            T__ kd_log10;
            (void) kd_log10;  // dummy to suppress unused var warning

            stan::math::initialize(kd_log10, DUMMY_VAR__);
            stan::math::fill(kd_log10,DUMMY_VAR__);
            stan::math::assign(kd_log10,(kd_meanlog10 + (kd_sdlog10 * get_base1(sigma,2,"sigma",1))));
            T__ alpha_log10;
            (void) alpha_log10;  // dummy to suppress unused var warning

            stan::math::initialize(alpha_log10, DUMMY_VAR__);
            stan::math::fill(alpha_log10,DUMMY_VAR__);
            stan::math::assign(alpha_log10,(alpha_meanlog10 + (alpha_sdlog10 * get_base1(sigma,3,"sigma",1))));
            T__ kk_log10;
            (void) kk_log10;  // dummy to suppress unused var warning

            stan::math::initialize(kk_log10, DUMMY_VAR__);
            stan::math::fill(kk_log10,DUMMY_VAR__);
            stan::math::assign(kk_log10,(kk_meanlog10 + (kk_sdlog10 * get_base1(sigma,4,"sigma",1))));
            validate_non_negative_index("param", "4", 4);
            vector<T__> param(4);
            stan::math::initialize(param, DUMMY_VAR__);
            stan::math::fill(param,DUMMY_VAR__);
            validate_non_negative_index("y_hat", "n_data_Nsurv", n_data_Nsurv);
            validate_non_negative_index("y_hat", "2", 2);
            Eigen::Matrix<T__,Eigen::Dynamic,Eigen::Dynamic>  y_hat(static_cast<Eigen::VectorXd::Index>(n_data_Nsurv),static_cast<Eigen::VectorXd::Index>(2));
            (void) y_hat;  // dummy to suppress unused var warning

            stan::math::initialize(y_hat, DUMMY_VAR__);
            stan::math::fill(y_hat,DUMMY_VAR__);
            validate_non_negative_index("Psurv_hat", "n_data_Nsurv", n_data_Nsurv);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Psurv_hat(static_cast<Eigen::VectorXd::Index>(n_data_Nsurv));
            (void) Psurv_hat;  // dummy to suppress unused var warning

            stan::math::initialize(Psurv_hat, DUMMY_VAR__);
            stan::math::fill(Psurv_hat,DUMMY_VAR__);
            validate_non_negative_index("Conditional_Psurv_hat", "n_data_Nsurv", n_data_Nsurv);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Conditional_Psurv_hat(static_cast<Eigen::VectorXd::Index>(n_data_Nsurv));
            (void) Conditional_Psurv_hat;  // dummy to suppress unused var warning

            stan::math::initialize(Conditional_Psurv_hat, DUMMY_VAR__);
            stan::math::fill(Conditional_Psurv_hat,DUMMY_VAR__);


            stan::math::assign(get_base1_lhs(param,1,"param",1), pow(10,hb_log10));
            stan::math::assign(get_base1_lhs(param,2,"param",1), pow(10,kd_log10));
            stan::math::assign(get_base1_lhs(param,3,"param",1), z);
            stan::math::assign(get_base1_lhs(param,4,"param",1), pow(10,kk_log10));
            for (int gr = 1; gr <= n_group; ++gr) {

                stan::model::assign(y_hat, 
                            stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list())), 
                            solve_TKTD_varPROPER(y0,0,stan::model::rvalue(tNsurv_ode, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "tNsurv_ode"),param,stan::model::rvalue(tconc_ode, stan::model::cons_list(stan::model::index_min_max(get_base1(idC_lw,gr,"idC_lw",1), get_base1(idC_up,gr,"idC_up",1)), stan::model::nil_index_list()), "tconc_ode"),stan::model::rvalue(conc, stan::model::cons_list(stan::model::index_min_max(get_base1(idC_lw,gr,"idC_lw",1), get_base1(idC_up,gr,"idC_up",1)), stan::model::nil_index_list()), "conc"),odeParam, pstream__), 
                            "assigning variable y_hat");
                stan::model::assign(Psurv_hat, 
                            stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), 
                            exp(minus(stan::model::rvalue(y_hat, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "y_hat"))), 
                            "assigning variable Psurv_hat");
                for (int i = get_base1(idS_lw,gr,"idS_lw",1); i <= get_base1(idS_up,gr,"idS_up",1); ++i) {

                    stan::math::assign(get_base1_lhs(Conditional_Psurv_hat,i,"Conditional_Psurv_hat",1), (logical_eq(i,get_base1(idS_lw,gr,"idS_lw",1)) ? stan::math::promote_scalar<T__>(get_base1(Psurv_hat,i,"Psurv_hat",1)) : stan::math::promote_scalar<T__>((get_base1(Psurv_hat,i,"Psurv_hat",1) / get_base1(Psurv_hat,(i - 1),"Psurv_hat",1))) ));
                }
            }

            // validate transformed parameters
            if (stan::math::is_uninitialized(hb_log10)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: hb_log10";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(kd_log10)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: kd_log10";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(alpha_log10)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: alpha_log10";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(kk_log10)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: kk_log10";
                throw std::runtime_error(msg__.str());
            }
            for (int i0__ = 0; i0__ < 4; ++i0__) {
                if (stan::math::is_uninitialized(param[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: param" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < n_data_Nsurv; ++i0__) {
                for (int i1__ = 0; i1__ < 2; ++i1__) {
                    if (stan::math::is_uninitialized(y_hat(i0__,i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: y_hat" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < n_data_Nsurv; ++i0__) {
                if (stan::math::is_uninitialized(Psurv_hat(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Psurv_hat" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < n_data_Nsurv; ++i0__) {
                if (stan::math::is_uninitialized(Conditional_Psurv_hat(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Conditional_Psurv_hat" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            for (int k0__ = 0; k0__ < 4; ++k0__) {
                check_greater_or_equal(function__,"param[k0__]",param[k0__],0);
            }
            check_greater_or_equal(function__,"Psurv_hat",Psurv_hat,0);
            check_less_or_equal(function__,"Psurv_hat",Psurv_hat,1);
            check_greater_or_equal(function__,"Conditional_Psurv_hat",Conditional_Psurv_hat,0);
            check_less_or_equal(function__,"Conditional_Psurv_hat",Conditional_Psurv_hat,1);

            // model body

            lp_accum__.add(normal_log(sigma,0,1));
            lp_accum__.add(uniform_log(beta_log10,beta_minlog10,beta_maxlog10));
            if (as_bool(logical_eq(proper_distribution,1))) {

                lp_accum__.add(loglogistic_lpdf(z,pow(10,alpha_log10),pow(10,beta_log10), pstream__));
            }
            if (as_bool(logical_eq(proper_distribution,2))) {

                lp_accum__.add(lognormal_log(z,pow(10,alpha_log10),pow(10,beta_log10)));
            }
            for (int gr = 1; gr <= n_group; ++gr) {

                lp_accum__.add(binomial_log(stan::model::rvalue(Nsurv, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "Nsurv"),stan::model::rvalue(Nprec, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "Nprec"),stan::model::rvalue(Conditional_Psurv_hat, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "Conditional_Psurv_hat")));
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("sigma");
        names__.push_back("beta_log10");
        names__.push_back("z");
        names__.push_back("hb_log10");
        names__.push_back("kd_log10");
        names__.push_back("alpha_log10");
        names__.push_back("kk_log10");
        names__.push_back("param");
        names__.push_back("y_hat");
        names__.push_back("Psurv_hat");
        names__.push_back("Conditional_Psurv_hat");
        names__.push_back("Nsurv_ppc");
        names__.push_back("Nsurv_sim");
        names__.push_back("Nsurv_sim_prec");
        names__.push_back("log_lik");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_data_Nsurv);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_data_Nsurv);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_data_Nsurv);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_data_Nsurv);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_data_Nsurv);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_data_Nsurv);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_data_Nsurv);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_ode_TKTD_varPROPER_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector<double> sigma;
        size_t dim_sigma_0__ = 4;
        for (size_t k_0__ = 0; k_0__ < dim_sigma_0__; ++k_0__) {
            sigma.push_back(in__.scalar_constrain());
        }
        double beta_log10 = in__.scalar_constrain();
        double z = in__.scalar_constrain();
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
        vars__.push_back(beta_log10);
        vars__.push_back(z);

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            double hb_log10(0.0);
            (void) hb_log10;  // dummy to suppress unused var warning

            stan::math::initialize(hb_log10, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(hb_log10,DUMMY_VAR__);
            stan::math::assign(hb_log10,(hb_meanlog10 + (hb_sdlog10 * get_base1(sigma,1,"sigma",1))));
            double kd_log10(0.0);
            (void) kd_log10;  // dummy to suppress unused var warning

            stan::math::initialize(kd_log10, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(kd_log10,DUMMY_VAR__);
            stan::math::assign(kd_log10,(kd_meanlog10 + (kd_sdlog10 * get_base1(sigma,2,"sigma",1))));
            double alpha_log10(0.0);
            (void) alpha_log10;  // dummy to suppress unused var warning

            stan::math::initialize(alpha_log10, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(alpha_log10,DUMMY_VAR__);
            stan::math::assign(alpha_log10,(alpha_meanlog10 + (alpha_sdlog10 * get_base1(sigma,3,"sigma",1))));
            double kk_log10(0.0);
            (void) kk_log10;  // dummy to suppress unused var warning

            stan::math::initialize(kk_log10, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(kk_log10,DUMMY_VAR__);
            stan::math::assign(kk_log10,(kk_meanlog10 + (kk_sdlog10 * get_base1(sigma,4,"sigma",1))));
            validate_non_negative_index("param", "4", 4);
            vector<double> param(4, 0.0);
            stan::math::initialize(param, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(param,DUMMY_VAR__);
            validate_non_negative_index("y_hat", "n_data_Nsurv", n_data_Nsurv);
            validate_non_negative_index("y_hat", "2", 2);
            matrix_d y_hat(static_cast<Eigen::VectorXd::Index>(n_data_Nsurv),static_cast<Eigen::VectorXd::Index>(2));
            (void) y_hat;  // dummy to suppress unused var warning

            stan::math::initialize(y_hat, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_hat,DUMMY_VAR__);
            validate_non_negative_index("Psurv_hat", "n_data_Nsurv", n_data_Nsurv);
            vector_d Psurv_hat(static_cast<Eigen::VectorXd::Index>(n_data_Nsurv));
            (void) Psurv_hat;  // dummy to suppress unused var warning

            stan::math::initialize(Psurv_hat, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Psurv_hat,DUMMY_VAR__);
            validate_non_negative_index("Conditional_Psurv_hat", "n_data_Nsurv", n_data_Nsurv);
            vector_d Conditional_Psurv_hat(static_cast<Eigen::VectorXd::Index>(n_data_Nsurv));
            (void) Conditional_Psurv_hat;  // dummy to suppress unused var warning

            stan::math::initialize(Conditional_Psurv_hat, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Conditional_Psurv_hat,DUMMY_VAR__);


            stan::math::assign(get_base1_lhs(param,1,"param",1), pow(10,hb_log10));
            stan::math::assign(get_base1_lhs(param,2,"param",1), pow(10,kd_log10));
            stan::math::assign(get_base1_lhs(param,3,"param",1), z);
            stan::math::assign(get_base1_lhs(param,4,"param",1), pow(10,kk_log10));
            for (int gr = 1; gr <= n_group; ++gr) {

                stan::model::assign(y_hat, 
                            stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list())), 
                            solve_TKTD_varPROPER(y0,0,stan::model::rvalue(tNsurv_ode, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "tNsurv_ode"),param,stan::model::rvalue(tconc_ode, stan::model::cons_list(stan::model::index_min_max(get_base1(idC_lw,gr,"idC_lw",1), get_base1(idC_up,gr,"idC_up",1)), stan::model::nil_index_list()), "tconc_ode"),stan::model::rvalue(conc, stan::model::cons_list(stan::model::index_min_max(get_base1(idC_lw,gr,"idC_lw",1), get_base1(idC_up,gr,"idC_up",1)), stan::model::nil_index_list()), "conc"),odeParam, pstream__), 
                            "assigning variable y_hat");
                stan::model::assign(Psurv_hat, 
                            stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), 
                            exp(minus(stan::model::rvalue(y_hat, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "y_hat"))), 
                            "assigning variable Psurv_hat");
                for (int i = get_base1(idS_lw,gr,"idS_lw",1); i <= get_base1(idS_up,gr,"idS_up",1); ++i) {

                    stan::math::assign(get_base1_lhs(Conditional_Psurv_hat,i,"Conditional_Psurv_hat",1), (logical_eq(i,get_base1(idS_lw,gr,"idS_lw",1)) ? stan::math::promote_scalar<double>(get_base1(Psurv_hat,i,"Psurv_hat",1)) : stan::math::promote_scalar<double>((get_base1(Psurv_hat,i,"Psurv_hat",1) / get_base1(Psurv_hat,(i - 1),"Psurv_hat",1))) ));
                }
            }

            // validate transformed parameters
            for (int k0__ = 0; k0__ < 4; ++k0__) {
                check_greater_or_equal(function__,"param[k0__]",param[k0__],0);
            }
            check_greater_or_equal(function__,"Psurv_hat",Psurv_hat,0);
            check_less_or_equal(function__,"Psurv_hat",Psurv_hat,1);
            check_greater_or_equal(function__,"Conditional_Psurv_hat",Conditional_Psurv_hat,0);
            check_less_or_equal(function__,"Conditional_Psurv_hat",Conditional_Psurv_hat,1);

            // write transformed parameters
        vars__.push_back(hb_log10);
        vars__.push_back(kd_log10);
        vars__.push_back(alpha_log10);
        vars__.push_back(kk_log10);
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(param[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < 2; ++k_1__) {
                for (int k_0__ = 0; k_0__ < n_data_Nsurv; ++k_0__) {
                vars__.push_back(y_hat(k_0__, k_1__));
                }
            }
            for (int k_0__ = 0; k_0__ < n_data_Nsurv; ++k_0__) {
            vars__.push_back(Psurv_hat[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < n_data_Nsurv; ++k_0__) {
            vars__.push_back(Conditional_Psurv_hat[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            validate_non_negative_index("Nsurv_ppc", "n_data_Nsurv", n_data_Nsurv);
            vector<int> Nsurv_ppc(n_data_Nsurv, 0);
            stan::math::fill(Nsurv_ppc, std::numeric_limits<int>::min());
            validate_non_negative_index("Nsurv_sim", "n_data_Nsurv", n_data_Nsurv);
            vector<int> Nsurv_sim(n_data_Nsurv, 0);
            stan::math::fill(Nsurv_sim, std::numeric_limits<int>::min());
            validate_non_negative_index("Nsurv_sim_prec", "n_data_Nsurv", n_data_Nsurv);
            vector<int> Nsurv_sim_prec(n_data_Nsurv, 0);
            stan::math::fill(Nsurv_sim_prec, std::numeric_limits<int>::min());
            validate_non_negative_index("log_lik", "n_data_Nsurv", n_data_Nsurv);
            vector_d log_lik(static_cast<Eigen::VectorXd::Index>(n_data_Nsurv));
            (void) log_lik;  // dummy to suppress unused var warning

            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);


            for (int gr = 1; gr <= n_group; ++gr) {

                for (int i = get_base1(idS_lw,gr,"idS_lw",1); i <= get_base1(idS_up,gr,"idS_up",1); ++i) {

                    stan::math::assign(get_base1_lhs(Nsurv_ppc,i,"Nsurv_ppc",1), binomial_rng(get_base1(Nprec,i,"Nprec",1),get_base1(Conditional_Psurv_hat,i,"Conditional_Psurv_hat",1), base_rng__));
                    stan::math::assign(get_base1_lhs(Nsurv_sim_prec,i,"Nsurv_sim_prec",1), (logical_eq(i,get_base1(idS_lw,gr,"idS_lw",1)) ? get_base1(Nprec,i,"Nprec",1) : get_base1(Nsurv_sim,(i - 1),"Nsurv_sim",1) ));
                    stan::math::assign(get_base1_lhs(Nsurv_sim,i,"Nsurv_sim",1), binomial_rng(get_base1(Nsurv_sim_prec,i,"Nsurv_sim_prec",1),get_base1(Conditional_Psurv_hat,i,"Conditional_Psurv_hat",1), base_rng__));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), binomial_log(stan::model::rvalue(Nsurv, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "Nsurv"),stan::model::rvalue(Nprec, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "Nprec"),stan::model::rvalue(Conditional_Psurv_hat, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "Conditional_Psurv_hat")));
                }
            }

            // validate generated quantities

            // write generated quantities
            for (int k_0__ = 0; k_0__ < n_data_Nsurv; ++k_0__) {
            vars__.push_back(Nsurv_ppc[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < n_data_Nsurv; ++k_0__) {
            vars__.push_back(Nsurv_sim[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < n_data_Nsurv; ++k_0__) {
            vars__.push_back(Nsurv_sim_prec[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < n_data_Nsurv; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_ode_TKTD_varPROPER";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta_log10";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "z";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "hb_log10";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "kd_log10";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "alpha_log10";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "kk_log10";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "param" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_hat" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Psurv_hat" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Conditional_Psurv_hat" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Nsurv_ppc" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Nsurv_sim" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Nsurv_sim_prec" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta_log10";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "z";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "hb_log10";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "kd_log10";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "alpha_log10";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "kk_log10";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "param" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_hat" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Psurv_hat" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Conditional_Psurv_hat" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Nsurv_ppc" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Nsurv_sim" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Nsurv_sim_prec" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_ode_TKTD_varSD_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_ode_TKTD_varSD");
    reader.add_event(264, 264, "end", "model_ode_TKTD_varSD");
    return reader;
}

template <typename T0__, typename T1__>
int
find_interval_elem(const T0__& x,
                       const Eigen::Matrix<T1__, Eigen::Dynamic,1>& sorted,
                       const int& start_ind, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        int res(0);
        (void) res;  // dummy to suppress unused var warning

        stan::math::fill(res, std::numeric_limits<int>::min());
        int N(0);
        (void) N;  // dummy to suppress unused var warning

        stan::math::fill(N, std::numeric_limits<int>::min());
        int max_iter(0);
        (void) max_iter;  // dummy to suppress unused var warning

        stan::math::fill(max_iter, std::numeric_limits<int>::min());
        fun_scalar_t__ left;
        (void) left;  // dummy to suppress unused var warning

        stan::math::initialize(left, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(left,DUMMY_VAR__);
        fun_scalar_t__ right;
        (void) right;  // dummy to suppress unused var warning

        stan::math::initialize(right, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(right,DUMMY_VAR__);
        int left_ind(0);
        (void) left_ind;  // dummy to suppress unused var warning

        stan::math::fill(left_ind, std::numeric_limits<int>::min());
        int right_ind(0);
        (void) right_ind;  // dummy to suppress unused var warning

        stan::math::fill(right_ind, std::numeric_limits<int>::min());
        int iter(0);
        (void) iter;  // dummy to suppress unused var warning

        stan::math::fill(iter, std::numeric_limits<int>::min());


        stan::math::assign(N, num_elements(sorted));
        if (as_bool(logical_eq(N,0))) {
            return stan::math::promote_scalar<fun_return_scalar_t__>(0);
        }
        stan::math::assign(left_ind, start_ind);
        stan::math::assign(right_ind, N);
        stan::math::assign(max_iter, (100 * N));
        stan::math::assign(left, (get_base1(sorted,left_ind,"sorted",1) - x));
        stan::math::assign(right, (get_base1(sorted,right_ind,"sorted",1) - x));
        if (as_bool(logical_lte(0,left))) {
            return stan::math::promote_scalar<fun_return_scalar_t__>((left_ind - 1));
        }
        if (as_bool(logical_eq(0,right))) {
            return stan::math::promote_scalar<fun_return_scalar_t__>((N - 1));
        }
        if (as_bool(logical_gt(0,right))) {
            return stan::math::promote_scalar<fun_return_scalar_t__>(N);
        }
        stan::math::assign(iter, 1);
        while (as_bool((primitive_value(logical_gt((right_ind - left_ind),1)) && primitive_value(logical_neq(iter,max_iter))))) {
            {
            int mid_ind(0);
            (void) mid_ind;  // dummy to suppress unused var warning

            stan::math::fill(mid_ind, std::numeric_limits<int>::min());
            fun_scalar_t__ mid;
            (void) mid;  // dummy to suppress unused var warning

            stan::math::initialize(mid, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mid,DUMMY_VAR__);


            stan::math::assign(mid_ind, divide((left_ind + right_ind),2));
            stan::math::assign(mid, (get_base1(sorted,mid_ind,"sorted",1) - x));
            if (as_bool(logical_eq(mid,0))) {
                return stan::math::promote_scalar<fun_return_scalar_t__>((mid_ind - 1));
            }
            if (as_bool(logical_lt((left * mid),0))) {

                stan::math::assign(right, mid);
                stan::math::assign(right_ind, mid_ind);
            }
            if (as_bool(logical_lt((right * mid),0))) {

                stan::math::assign(left, mid);
                stan::math::assign(left_ind, mid_ind);
            }
            stan::math::assign(iter, (iter + 1));
            }
        }
        if (as_bool(logical_eq(iter,max_iter))) {
            if (pstream__) {
                stan_print(pstream__,"Maximum number of iterations reached.");
                *pstream__ << std::endl;
            }
        }
        return stan::math::promote_scalar<fun_return_scalar_t__>(left_ind);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct find_interval_elem_functor__ {
    template <typename T0__, typename T1__>
        int
    operator()(const T0__& x,
                       const Eigen::Matrix<T1__, Eigen::Dynamic,1>& sorted,
                       const int& start_ind, std::ostream* pstream__) const {
        return find_interval_elem(x, sorted, start_ind, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
linearInterp(const T0__& t_x,
                 const T1__& t_before,
                 const T2__& t_after,
                 const T3__& y_before,
                 const T4__& y_after, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        fun_scalar_t__ linInterp_hat;
        (void) linInterp_hat;  // dummy to suppress unused var warning

        stan::math::initialize(linInterp_hat, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(linInterp_hat,DUMMY_VAR__);


        stan::math::assign(linInterp_hat, (y_before + (((t_x - t_before) * (y_after - y_before)) / (t_after - t_before))));
        return stan::math::promote_scalar<fun_return_scalar_t__>(linInterp_hat);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct linearInterp_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type
    operator()(const T0__& t_x,
                 const T1__& t_before,
                 const T2__& t_after,
                 const T3__& y_before,
                 const T4__& y_after, std::ostream* pstream__) const {
        return linearInterp(t_x, t_before, t_after, y_before, y_after, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
loglogistic_lpdf(const T0__& y_hat,
                     const T1__& alpha,
                     const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        return stan::math::promote_scalar<fun_return_scalar_t__>((((log(beta) - log(alpha)) + ((beta - 1) * (log(y_hat) - log(alpha)))) - (2 * log1p_exp((beta * (log(y_hat) - log(alpha)))))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
loglogistic_lpdf(const T0__& y_hat,
                     const T1__& alpha,
                     const T2__& beta, std::ostream* pstream__) {
    return loglogistic_lpdf<false>(y_hat,alpha,beta, pstream__);
}


struct loglogistic_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y_hat,
                     const T1__& alpha,
                     const T2__& beta, std::ostream* pstream__) const {
        return loglogistic_lpdf(y_hat, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
loglogistic_lcdf(const T0__& y_hat,
                     const T1__& alpha,
                     const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        return stan::math::promote_scalar<fun_return_scalar_t__>(-(log1p_exp((-(beta) * (log(y_hat) - log(alpha))))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct loglogistic_lcdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y_hat,
                     const T1__& alpha,
                     const T2__& beta, std::ostream* pstream__) const {
        return loglogistic_lcdf(y_hat, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
loglogistic_lccdf(const T0__& y_hat,
                      const T1__& alpha,
                      const T2__& beta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        return stan::math::promote_scalar<fun_return_scalar_t__>(-(log1p_exp((beta * (log(y_hat) - log(alpha))))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct loglogistic_lccdf_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__>::type
    operator()(const T0__& y_hat,
                      const T1__& alpha,
                      const T2__& beta, std::ostream* pstream__) const {
        return loglogistic_lccdf(y_hat, alpha, beta, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
std::vector<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type>
TKTD_varSD(const T0__& t,
               const std::vector<T1__>& y,
               const std::vector<T2__>& theta,
               const std::vector<T3__>& x_r,
               const std::vector<int>& x_i, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        fun_scalar_t__ hb;
        (void) hb;  // dummy to suppress unused var warning

        stan::math::initialize(hb, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(hb,DUMMY_VAR__);
        stan::math::assign(hb,get_base1(theta,1,"theta",1));
        fun_scalar_t__ kd;
        (void) kd;  // dummy to suppress unused var warning

        stan::math::initialize(kd, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(kd,DUMMY_VAR__);
        stan::math::assign(kd,get_base1(theta,2,"theta",1));
        fun_scalar_t__ z;
        (void) z;  // dummy to suppress unused var warning

        stan::math::initialize(z, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(z,DUMMY_VAR__);
        stan::math::assign(z,get_base1(theta,3,"theta",1));
        fun_scalar_t__ kk;
        (void) kk;  // dummy to suppress unused var warning

        stan::math::initialize(kk, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(kk,DUMMY_VAR__);
        stan::math::assign(kk,get_base1(theta,4,"theta",1));
        validate_non_negative_index("max_z", "2", 2);
        vector<fun_scalar_t__> max_z(2);
        stan::math::initialize(max_z, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(max_z,DUMMY_VAR__);
        validate_non_negative_index("dy_dt", "2", 2);
        vector<fun_scalar_t__> dy_dt(2);
        stan::math::initialize(dy_dt, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(dy_dt,DUMMY_VAR__);
        int Nconc(0);
        (void) Nconc;  // dummy to suppress unused var warning

        stan::math::fill(Nconc, std::numeric_limits<int>::min());
        stan::math::assign(Nconc,get_base1(x_i,1,"x_i",1));
        validate_non_negative_index("tconc", "Nconc", Nconc);
        Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  tconc(static_cast<Eigen::VectorXd::Index>(Nconc));
        (void) tconc;  // dummy to suppress unused var warning

        stan::math::initialize(tconc, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(tconc,DUMMY_VAR__);
        stan::math::assign(tconc,to_vector(stan::model::rvalue(x_r, stan::model::cons_list(stan::model::index_min_max(1, Nconc), stan::model::nil_index_list()), "x_r")));
        validate_non_negative_index("conc", "Nconc", Nconc);
        Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  conc(static_cast<Eigen::VectorXd::Index>(Nconc));
        (void) conc;  // dummy to suppress unused var warning

        stan::math::initialize(conc, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(conc,DUMMY_VAR__);
        stan::math::assign(conc,to_vector(stan::model::rvalue(x_r, stan::model::cons_list(stan::model::index_min_max((Nconc + 1), (2 * Nconc)), stan::model::nil_index_list()), "x_r")));
        int pulse_index(0);
        (void) pulse_index;  // dummy to suppress unused var warning

        stan::math::fill(pulse_index, std::numeric_limits<int>::min());
        stan::math::assign(pulse_index,find_interval_elem(t,tconc,1, pstream__));
        fun_scalar_t__ conc_linInterp;
        (void) conc_linInterp;  // dummy to suppress unused var warning

        stan::math::initialize(conc_linInterp, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(conc_linInterp,DUMMY_VAR__);
        stan::math::assign(conc_linInterp,(logical_neq(pulse_index,0) ? stan::math::promote_scalar<fun_scalar_t__>(linearInterp(t,get_base1(tconc,pulse_index,"tconc",1),get_base1(tconc,(pulse_index + 1),"tconc",1),get_base1(conc,pulse_index,"conc",1),get_base1(conc,(pulse_index + 1),"conc",1), pstream__)) : stan::math::promote_scalar<fun_scalar_t__>(get_base1(conc,1,"conc",1)) ));


        stan::math::assign(get_base1_lhs(dy_dt,1,"dy_dt",1), (kd * (conc_linInterp - get_base1(y,1,"y",1))));
        stan::math::assign(get_base1_lhs(max_z,1,"max_z",1), 0);
        stan::math::assign(get_base1_lhs(max_z,2,"max_z",1), (get_base1(y,1,"y",1) - z));
        stan::math::assign(get_base1_lhs(dy_dt,2,"dy_dt",1), ((kk * max(max_z)) + hb));
        return stan::math::promote_scalar<fun_return_scalar_t__>(dy_dt);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct TKTD_varSD_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        std::vector<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type>
    operator()(const T0__& t,
               const std::vector<T1__>& y,
               const std::vector<T2__>& theta,
               const std::vector<T3__>& x_r,
               const std::vector<int>& x_i, std::ostream* pstream__) const {
        return TKTD_varSD(t, y, theta, x_r, x_i, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
solve_TKTD_varSD(const std::vector<T0__>& y0,
                     const T1__& t0,
                     const std::vector<T2__>& ts,
                     const std::vector<T3__>& theta,
                     const std::vector<T4__>& tconc,
                     const std::vector<T5__>& conc,
                     const std::vector<T6__>& odeParam, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        validate_non_negative_index("x_i", "1", 1);
        vector<int> x_i(1, 0);
        stan::math::fill(x_i, std::numeric_limits<int>::min());


        stan::math::assign(get_base1_lhs(x_i,1,"x_i",1), size(tconc));
        return stan::math::promote_scalar<fun_return_scalar_t__>(to_matrix(integrate_ode_rk45(TKTD_varSD_functor__(), y0, t0, ts, theta, to_array_1d(append_row(to_vector(tconc),to_vector(conc))), x_i, pstream__, get_base1(odeParam,1,"odeParam",1), get_base1(odeParam,2,"odeParam",1), get_base1(odeParam,3,"odeParam",1))));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct solve_TKTD_varSD_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const std::vector<T0__>& y0,
                     const T1__& t0,
                     const std::vector<T2__>& ts,
                     const std::vector<T3__>& theta,
                     const std::vector<T4__>& tconc,
                     const std::vector<T5__>& conc,
                     const std::vector<T6__>& odeParam, std::ostream* pstream__) const {
        return solve_TKTD_varSD(y0, t0, ts, theta, tconc, conc, odeParam, pstream__);
    }
};

class model_ode_TKTD_varSD : public prob_grad {
private:
    int n_group;
    int n_data_conc;
    vector<double> conc;
    vector<double> tconc;
    vector<int> idC_lw;
    vector<int> idC_up;
    int n_data_Nsurv;
    vector<int> Nsurv;
    vector<int> Nprec;
    vector<double> tNsurv;
    vector<int> idS_lw;
    vector<int> idS_up;
    double hb_meanlog10;
    double hb_sdlog10;
    double kd_meanlog10;
    double kd_sdlog10;
    double rel_tol;
    double abs_tol;
    int max_num_steps;
    double kk_meanlog10;
    double kk_sdlog10;
    double z_meanlog10;
    double z_sdlog10;
    vector<double> y0;
    vector<double> odeParam;
    vector<double> tNsurv_ode;
    vector<double> tconc_ode;
public:
    model_ode_TKTD_varSD(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_ode_TKTD_varSD(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_ode_TKTD_varSD_namespace::model_ode_TKTD_varSD";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "n_group", "int", context__.to_vec());
            n_group = int(0);
            vals_i__ = context__.vals_i("n_group");
            pos__ = 0;
            n_group = vals_i__[pos__++];
            context__.validate_dims("data initialization", "n_data_conc", "int", context__.to_vec());
            n_data_conc = int(0);
            vals_i__ = context__.vals_i("n_data_conc");
            pos__ = 0;
            n_data_conc = vals_i__[pos__++];
            validate_non_negative_index("conc", "n_data_conc", n_data_conc);
            context__.validate_dims("data initialization", "conc", "double", context__.to_vec(n_data_conc));
            validate_non_negative_index("conc", "n_data_conc", n_data_conc);
            conc = std::vector<double>(n_data_conc,double(0));
            vals_r__ = context__.vals_r("conc");
            pos__ = 0;
            size_t conc_limit_0__ = n_data_conc;
            for (size_t i_0__ = 0; i_0__ < conc_limit_0__; ++i_0__) {
                conc[i_0__] = vals_r__[pos__++];
            }
            validate_non_negative_index("tconc", "n_data_conc", n_data_conc);
            context__.validate_dims("data initialization", "tconc", "double", context__.to_vec(n_data_conc));
            validate_non_negative_index("tconc", "n_data_conc", n_data_conc);
            tconc = std::vector<double>(n_data_conc,double(0));
            vals_r__ = context__.vals_r("tconc");
            pos__ = 0;
            size_t tconc_limit_0__ = n_data_conc;
            for (size_t i_0__ = 0; i_0__ < tconc_limit_0__; ++i_0__) {
                tconc[i_0__] = vals_r__[pos__++];
            }
            validate_non_negative_index("idC_lw", "n_group", n_group);
            context__.validate_dims("data initialization", "idC_lw", "int", context__.to_vec(n_group));
            validate_non_negative_index("idC_lw", "n_group", n_group);
            idC_lw = std::vector<int>(n_group,int(0));
            vals_i__ = context__.vals_i("idC_lw");
            pos__ = 0;
            size_t idC_lw_limit_0__ = n_group;
            for (size_t i_0__ = 0; i_0__ < idC_lw_limit_0__; ++i_0__) {
                idC_lw[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("idC_up", "n_group", n_group);
            context__.validate_dims("data initialization", "idC_up", "int", context__.to_vec(n_group));
            validate_non_negative_index("idC_up", "n_group", n_group);
            idC_up = std::vector<int>(n_group,int(0));
            vals_i__ = context__.vals_i("idC_up");
            pos__ = 0;
            size_t idC_up_limit_0__ = n_group;
            for (size_t i_0__ = 0; i_0__ < idC_up_limit_0__; ++i_0__) {
                idC_up[i_0__] = vals_i__[pos__++];
            }
            context__.validate_dims("data initialization", "n_data_Nsurv", "int", context__.to_vec());
            n_data_Nsurv = int(0);
            vals_i__ = context__.vals_i("n_data_Nsurv");
            pos__ = 0;
            n_data_Nsurv = vals_i__[pos__++];
            validate_non_negative_index("Nsurv", "n_data_Nsurv", n_data_Nsurv);
            context__.validate_dims("data initialization", "Nsurv", "int", context__.to_vec(n_data_Nsurv));
            validate_non_negative_index("Nsurv", "n_data_Nsurv", n_data_Nsurv);
            Nsurv = std::vector<int>(n_data_Nsurv,int(0));
            vals_i__ = context__.vals_i("Nsurv");
            pos__ = 0;
            size_t Nsurv_limit_0__ = n_data_Nsurv;
            for (size_t i_0__ = 0; i_0__ < Nsurv_limit_0__; ++i_0__) {
                Nsurv[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("Nprec", "n_data_Nsurv", n_data_Nsurv);
            context__.validate_dims("data initialization", "Nprec", "int", context__.to_vec(n_data_Nsurv));
            validate_non_negative_index("Nprec", "n_data_Nsurv", n_data_Nsurv);
            Nprec = std::vector<int>(n_data_Nsurv,int(0));
            vals_i__ = context__.vals_i("Nprec");
            pos__ = 0;
            size_t Nprec_limit_0__ = n_data_Nsurv;
            for (size_t i_0__ = 0; i_0__ < Nprec_limit_0__; ++i_0__) {
                Nprec[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("tNsurv", "n_data_Nsurv", n_data_Nsurv);
            context__.validate_dims("data initialization", "tNsurv", "double", context__.to_vec(n_data_Nsurv));
            validate_non_negative_index("tNsurv", "n_data_Nsurv", n_data_Nsurv);
            tNsurv = std::vector<double>(n_data_Nsurv,double(0));
            vals_r__ = context__.vals_r("tNsurv");
            pos__ = 0;
            size_t tNsurv_limit_0__ = n_data_Nsurv;
            for (size_t i_0__ = 0; i_0__ < tNsurv_limit_0__; ++i_0__) {
                tNsurv[i_0__] = vals_r__[pos__++];
            }
            validate_non_negative_index("idS_lw", "n_group", n_group);
            context__.validate_dims("data initialization", "idS_lw", "int", context__.to_vec(n_group));
            validate_non_negative_index("idS_lw", "n_group", n_group);
            idS_lw = std::vector<int>(n_group,int(0));
            vals_i__ = context__.vals_i("idS_lw");
            pos__ = 0;
            size_t idS_lw_limit_0__ = n_group;
            for (size_t i_0__ = 0; i_0__ < idS_lw_limit_0__; ++i_0__) {
                idS_lw[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("idS_up", "n_group", n_group);
            context__.validate_dims("data initialization", "idS_up", "int", context__.to_vec(n_group));
            validate_non_negative_index("idS_up", "n_group", n_group);
            idS_up = std::vector<int>(n_group,int(0));
            vals_i__ = context__.vals_i("idS_up");
            pos__ = 0;
            size_t idS_up_limit_0__ = n_group;
            for (size_t i_0__ = 0; i_0__ < idS_up_limit_0__; ++i_0__) {
                idS_up[i_0__] = vals_i__[pos__++];
            }
            context__.validate_dims("data initialization", "hb_meanlog10", "double", context__.to_vec());
            hb_meanlog10 = double(0);
            vals_r__ = context__.vals_r("hb_meanlog10");
            pos__ = 0;
            hb_meanlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "hb_sdlog10", "double", context__.to_vec());
            hb_sdlog10 = double(0);
            vals_r__ = context__.vals_r("hb_sdlog10");
            pos__ = 0;
            hb_sdlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "kd_meanlog10", "double", context__.to_vec());
            kd_meanlog10 = double(0);
            vals_r__ = context__.vals_r("kd_meanlog10");
            pos__ = 0;
            kd_meanlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "kd_sdlog10", "double", context__.to_vec());
            kd_sdlog10 = double(0);
            vals_r__ = context__.vals_r("kd_sdlog10");
            pos__ = 0;
            kd_sdlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "rel_tol", "double", context__.to_vec());
            rel_tol = double(0);
            vals_r__ = context__.vals_r("rel_tol");
            pos__ = 0;
            rel_tol = vals_r__[pos__++];
            context__.validate_dims("data initialization", "abs_tol", "double", context__.to_vec());
            abs_tol = double(0);
            vals_r__ = context__.vals_r("abs_tol");
            pos__ = 0;
            abs_tol = vals_r__[pos__++];
            context__.validate_dims("data initialization", "max_num_steps", "int", context__.to_vec());
            max_num_steps = int(0);
            vals_i__ = context__.vals_i("max_num_steps");
            pos__ = 0;
            max_num_steps = vals_i__[pos__++];
            context__.validate_dims("data initialization", "kk_meanlog10", "double", context__.to_vec());
            kk_meanlog10 = double(0);
            vals_r__ = context__.vals_r("kk_meanlog10");
            pos__ = 0;
            kk_meanlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "kk_sdlog10", "double", context__.to_vec());
            kk_sdlog10 = double(0);
            vals_r__ = context__.vals_r("kk_sdlog10");
            pos__ = 0;
            kk_sdlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "z_meanlog10", "double", context__.to_vec());
            z_meanlog10 = double(0);
            vals_r__ = context__.vals_r("z_meanlog10");
            pos__ = 0;
            z_meanlog10 = vals_r__[pos__++];
            context__.validate_dims("data initialization", "z_sdlog10", "double", context__.to_vec());
            z_sdlog10 = double(0);
            vals_r__ = context__.vals_r("z_sdlog10");
            pos__ = 0;
            z_sdlog10 = vals_r__[pos__++];

            // validate, data variables
            check_greater_or_equal(function__,"n_group",n_group,1);
            check_greater_or_equal(function__,"n_data_conc",n_data_conc,1);
            for (int k0__ = 0; k0__ < n_group; ++k0__) {
                check_greater_or_equal(function__,"idC_lw[k0__]",idC_lw[k0__],1);
            }
            for (int k0__ = 0; k0__ < n_group; ++k0__) {
                check_greater_or_equal(function__,"idC_up[k0__]",idC_up[k0__],1);
            }
            check_greater_or_equal(function__,"n_data_Nsurv",n_data_Nsurv,1);
            for (int k0__ = 0; k0__ < n_group; ++k0__) {
                check_greater_or_equal(function__,"idS_lw[k0__]",idS_lw[k0__],1);
            }
            for (int k0__ = 0; k0__ < n_group; ++k0__) {
                check_greater_or_equal(function__,"idS_up[k0__]",idS_up[k0__],1);
            }
            // initialize data variables
            validate_non_negative_index("y0", "2", 2);
            y0 = std::vector<double>(2,double(0));
            stan::math::fill(y0,DUMMY_VAR__);
            validate_non_negative_index("odeParam", "3", 3);
            odeParam = std::vector<double>(3,double(0));
            stan::math::fill(odeParam,DUMMY_VAR__);
            validate_non_negative_index("tNsurv_ode", "n_data_Nsurv", n_data_Nsurv);
            tNsurv_ode = std::vector<double>(n_data_Nsurv,double(0));
            stan::math::fill(tNsurv_ode,DUMMY_VAR__);
            validate_non_negative_index("tconc_ode", "n_data_conc", n_data_conc);
            tconc_ode = std::vector<double>(n_data_conc,double(0));
            stan::math::fill(tconc_ode,DUMMY_VAR__);

            stan::math::assign(get_base1_lhs(y0,1,"y0",1), 0);
            stan::math::assign(get_base1_lhs(y0,2,"y0",1), 0);
            stan::math::assign(get_base1_lhs(odeParam,1,"odeParam",1), rel_tol);
            stan::math::assign(get_base1_lhs(odeParam,2,"odeParam",1), abs_tol);
            stan::math::assign(get_base1_lhs(odeParam,3,"odeParam",1), max_num_steps);
            for (int gr = 1; gr <= n_group; ++gr) {

                stan::model::assign(tNsurv_ode, 
                            stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), 
                            stan::model::rvalue(tNsurv, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "tNsurv"), 
                            "assigning variable tNsurv_ode");
                stan::math::assign(get_base1_lhs(tNsurv_ode,get_base1(idS_lw,gr,"idS_lw",1),"tNsurv_ode",1), (get_base1(tNsurv,get_base1(idS_lw,gr,"idS_lw",1),"tNsurv",1) + 1.0000000000000001e-09));
                stan::model::assign(tconc_ode, 
                            stan::model::cons_list(stan::model::index_min_max(get_base1(idC_lw,gr,"idC_lw",1), get_base1(idC_up,gr,"idC_up",1)), stan::model::nil_index_list()), 
                            stan::model::rvalue(tconc, stan::model::cons_list(stan::model::index_min_max(get_base1(idC_lw,gr,"idC_lw",1), get_base1(idC_up,gr,"idC_up",1)), stan::model::nil_index_list()), "tconc"), 
                            "assigning variable tconc_ode");
                stan::math::assign(get_base1_lhs(tconc_ode,get_base1(idC_lw,gr,"idC_lw",1),"tconc_ode",1), (get_base1(tconc,get_base1(idC_lw,gr,"idC_lw",1),"tconc",1) + 1.0000000000000001e-09));
            }

            // validate transformed data
            for (int k0__ = 0; k0__ < 2; ++k0__) {
                check_greater_or_equal(function__,"y0[k0__]",y0[k0__],0);
            }

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("sigma", "4", 4);
            num_params_r__ += 4;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_ode_TKTD_varSD() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "4", 4);
        context__.validate_dims("initialization", "sigma", "double", context__.to_vec(4));
        std::vector<double> sigma(4,double(0));
        for (int i0__ = 0U; i0__ < 4; ++i0__)
            sigma[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < 4; ++i0__)
            try {
            writer__.scalar_unconstrain(sigma[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            vector<T__> sigma;
            size_t dim_sigma_0__ = 4;
            sigma.reserve(dim_sigma_0__);
            for (size_t k_0__ = 0; k_0__ < dim_sigma_0__; ++k_0__) {
                if (jacobian__)
                    sigma.push_back(in__.scalar_constrain(lp__));
                else
                    sigma.push_back(in__.scalar_constrain());
            }


            // transformed parameters
            T__ hb_log10;
            (void) hb_log10;  // dummy to suppress unused var warning

            stan::math::initialize(hb_log10, DUMMY_VAR__);
            stan::math::fill(hb_log10,DUMMY_VAR__);
            stan::math::assign(hb_log10,(hb_meanlog10 + (hb_sdlog10 * get_base1(sigma,1,"sigma",1))));
            T__ kd_log10;
            (void) kd_log10;  // dummy to suppress unused var warning

            stan::math::initialize(kd_log10, DUMMY_VAR__);
            stan::math::fill(kd_log10,DUMMY_VAR__);
            stan::math::assign(kd_log10,(kd_meanlog10 + (kd_sdlog10 * get_base1(sigma,2,"sigma",1))));
            T__ z_log10;
            (void) z_log10;  // dummy to suppress unused var warning

            stan::math::initialize(z_log10, DUMMY_VAR__);
            stan::math::fill(z_log10,DUMMY_VAR__);
            stan::math::assign(z_log10,(z_meanlog10 + (z_sdlog10 * get_base1(sigma,3,"sigma",1))));
            T__ kk_log10;
            (void) kk_log10;  // dummy to suppress unused var warning

            stan::math::initialize(kk_log10, DUMMY_VAR__);
            stan::math::fill(kk_log10,DUMMY_VAR__);
            stan::math::assign(kk_log10,(kk_meanlog10 + (kk_sdlog10 * get_base1(sigma,4,"sigma",1))));
            validate_non_negative_index("param", "4", 4);
            vector<T__> param(4);
            stan::math::initialize(param, DUMMY_VAR__);
            stan::math::fill(param,DUMMY_VAR__);
            validate_non_negative_index("y_hat", "n_data_Nsurv", n_data_Nsurv);
            validate_non_negative_index("y_hat", "2", 2);
            Eigen::Matrix<T__,Eigen::Dynamic,Eigen::Dynamic>  y_hat(static_cast<Eigen::VectorXd::Index>(n_data_Nsurv),static_cast<Eigen::VectorXd::Index>(2));
            (void) y_hat;  // dummy to suppress unused var warning

            stan::math::initialize(y_hat, DUMMY_VAR__);
            stan::math::fill(y_hat,DUMMY_VAR__);
            validate_non_negative_index("Psurv_hat", "n_data_Nsurv", n_data_Nsurv);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Psurv_hat(static_cast<Eigen::VectorXd::Index>(n_data_Nsurv));
            (void) Psurv_hat;  // dummy to suppress unused var warning

            stan::math::initialize(Psurv_hat, DUMMY_VAR__);
            stan::math::fill(Psurv_hat,DUMMY_VAR__);
            validate_non_negative_index("Conditional_Psurv_hat", "n_data_Nsurv", n_data_Nsurv);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  Conditional_Psurv_hat(static_cast<Eigen::VectorXd::Index>(n_data_Nsurv));
            (void) Conditional_Psurv_hat;  // dummy to suppress unused var warning

            stan::math::initialize(Conditional_Psurv_hat, DUMMY_VAR__);
            stan::math::fill(Conditional_Psurv_hat,DUMMY_VAR__);


            stan::math::assign(get_base1_lhs(param,1,"param",1), pow(10,hb_log10));
            stan::math::assign(get_base1_lhs(param,2,"param",1), pow(10,kd_log10));
            stan::math::assign(get_base1_lhs(param,3,"param",1), pow(10,z_log10));
            stan::math::assign(get_base1_lhs(param,4,"param",1), pow(10,kk_log10));
            for (int gr = 1; gr <= n_group; ++gr) {

                stan::model::assign(y_hat, 
                            stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list())), 
                            solve_TKTD_varSD(y0,0,stan::model::rvalue(tNsurv_ode, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "tNsurv_ode"),param,stan::model::rvalue(tconc_ode, stan::model::cons_list(stan::model::index_min_max(get_base1(idC_lw,gr,"idC_lw",1), get_base1(idC_up,gr,"idC_up",1)), stan::model::nil_index_list()), "tconc_ode"),stan::model::rvalue(conc, stan::model::cons_list(stan::model::index_min_max(get_base1(idC_lw,gr,"idC_lw",1), get_base1(idC_up,gr,"idC_up",1)), stan::model::nil_index_list()), "conc"),odeParam, pstream__), 
                            "assigning variable y_hat");
                stan::model::assign(Psurv_hat, 
                            stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), 
                            exp(minus(stan::model::rvalue(y_hat, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "y_hat"))), 
                            "assigning variable Psurv_hat");
                for (int i = get_base1(idS_lw,gr,"idS_lw",1); i <= get_base1(idS_up,gr,"idS_up",1); ++i) {

                    stan::math::assign(get_base1_lhs(Conditional_Psurv_hat,i,"Conditional_Psurv_hat",1), (logical_eq(i,get_base1(idS_lw,gr,"idS_lw",1)) ? stan::math::promote_scalar<T__>(get_base1(Psurv_hat,i,"Psurv_hat",1)) : stan::math::promote_scalar<T__>((get_base1(Psurv_hat,i,"Psurv_hat",1) / get_base1(Psurv_hat,(i - 1),"Psurv_hat",1))) ));
                }
            }

            // validate transformed parameters
            if (stan::math::is_uninitialized(hb_log10)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: hb_log10";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(kd_log10)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: kd_log10";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(z_log10)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: z_log10";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(kk_log10)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: kk_log10";
                throw std::runtime_error(msg__.str());
            }
            for (int i0__ = 0; i0__ < 4; ++i0__) {
                if (stan::math::is_uninitialized(param[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: param" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < n_data_Nsurv; ++i0__) {
                for (int i1__ = 0; i1__ < 2; ++i1__) {
                    if (stan::math::is_uninitialized(y_hat(i0__,i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: y_hat" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < n_data_Nsurv; ++i0__) {
                if (stan::math::is_uninitialized(Psurv_hat(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Psurv_hat" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < n_data_Nsurv; ++i0__) {
                if (stan::math::is_uninitialized(Conditional_Psurv_hat(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: Conditional_Psurv_hat" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            for (int k0__ = 0; k0__ < 4; ++k0__) {
                check_greater_or_equal(function__,"param[k0__]",param[k0__],0);
            }
            check_greater_or_equal(function__,"Psurv_hat",Psurv_hat,0);
            check_less_or_equal(function__,"Psurv_hat",Psurv_hat,1);
            check_greater_or_equal(function__,"Conditional_Psurv_hat",Conditional_Psurv_hat,0);
            check_less_or_equal(function__,"Conditional_Psurv_hat",Conditional_Psurv_hat,1);

            // model body

            lp_accum__.add(normal_log(sigma,0,1));
            for (int gr = 1; gr <= n_group; ++gr) {

                lp_accum__.add(binomial_log(stan::model::rvalue(Nsurv, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "Nsurv"),stan::model::rvalue(Nprec, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "Nprec"),stan::model::rvalue(Conditional_Psurv_hat, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "Conditional_Psurv_hat")));
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("sigma");
        names__.push_back("hb_log10");
        names__.push_back("kd_log10");
        names__.push_back("z_log10");
        names__.push_back("kk_log10");
        names__.push_back("param");
        names__.push_back("y_hat");
        names__.push_back("Psurv_hat");
        names__.push_back("Conditional_Psurv_hat");
        names__.push_back("Nsurv_ppc");
        names__.push_back("Nsurv_sim");
        names__.push_back("Nsurv_sim_prec");
        names__.push_back("log_lik");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(4);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_data_Nsurv);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_data_Nsurv);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_data_Nsurv);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_data_Nsurv);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_data_Nsurv);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_data_Nsurv);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_data_Nsurv);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_ode_TKTD_varSD_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector<double> sigma;
        size_t dim_sigma_0__ = 4;
        for (size_t k_0__ = 0; k_0__ < dim_sigma_0__; ++k_0__) {
            sigma.push_back(in__.scalar_constrain());
        }
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            double hb_log10(0.0);
            (void) hb_log10;  // dummy to suppress unused var warning

            stan::math::initialize(hb_log10, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(hb_log10,DUMMY_VAR__);
            stan::math::assign(hb_log10,(hb_meanlog10 + (hb_sdlog10 * get_base1(sigma,1,"sigma",1))));
            double kd_log10(0.0);
            (void) kd_log10;  // dummy to suppress unused var warning

            stan::math::initialize(kd_log10, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(kd_log10,DUMMY_VAR__);
            stan::math::assign(kd_log10,(kd_meanlog10 + (kd_sdlog10 * get_base1(sigma,2,"sigma",1))));
            double z_log10(0.0);
            (void) z_log10;  // dummy to suppress unused var warning

            stan::math::initialize(z_log10, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(z_log10,DUMMY_VAR__);
            stan::math::assign(z_log10,(z_meanlog10 + (z_sdlog10 * get_base1(sigma,3,"sigma",1))));
            double kk_log10(0.0);
            (void) kk_log10;  // dummy to suppress unused var warning

            stan::math::initialize(kk_log10, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(kk_log10,DUMMY_VAR__);
            stan::math::assign(kk_log10,(kk_meanlog10 + (kk_sdlog10 * get_base1(sigma,4,"sigma",1))));
            validate_non_negative_index("param", "4", 4);
            vector<double> param(4, 0.0);
            stan::math::initialize(param, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(param,DUMMY_VAR__);
            validate_non_negative_index("y_hat", "n_data_Nsurv", n_data_Nsurv);
            validate_non_negative_index("y_hat", "2", 2);
            matrix_d y_hat(static_cast<Eigen::VectorXd::Index>(n_data_Nsurv),static_cast<Eigen::VectorXd::Index>(2));
            (void) y_hat;  // dummy to suppress unused var warning

            stan::math::initialize(y_hat, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(y_hat,DUMMY_VAR__);
            validate_non_negative_index("Psurv_hat", "n_data_Nsurv", n_data_Nsurv);
            vector_d Psurv_hat(static_cast<Eigen::VectorXd::Index>(n_data_Nsurv));
            (void) Psurv_hat;  // dummy to suppress unused var warning

            stan::math::initialize(Psurv_hat, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Psurv_hat,DUMMY_VAR__);
            validate_non_negative_index("Conditional_Psurv_hat", "n_data_Nsurv", n_data_Nsurv);
            vector_d Conditional_Psurv_hat(static_cast<Eigen::VectorXd::Index>(n_data_Nsurv));
            (void) Conditional_Psurv_hat;  // dummy to suppress unused var warning

            stan::math::initialize(Conditional_Psurv_hat, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(Conditional_Psurv_hat,DUMMY_VAR__);


            stan::math::assign(get_base1_lhs(param,1,"param",1), pow(10,hb_log10));
            stan::math::assign(get_base1_lhs(param,2,"param",1), pow(10,kd_log10));
            stan::math::assign(get_base1_lhs(param,3,"param",1), pow(10,z_log10));
            stan::math::assign(get_base1_lhs(param,4,"param",1), pow(10,kk_log10));
            for (int gr = 1; gr <= n_group; ++gr) {

                stan::model::assign(y_hat, 
                            stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list())), 
                            solve_TKTD_varSD(y0,0,stan::model::rvalue(tNsurv_ode, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "tNsurv_ode"),param,stan::model::rvalue(tconc_ode, stan::model::cons_list(stan::model::index_min_max(get_base1(idC_lw,gr,"idC_lw",1), get_base1(idC_up,gr,"idC_up",1)), stan::model::nil_index_list()), "tconc_ode"),stan::model::rvalue(conc, stan::model::cons_list(stan::model::index_min_max(get_base1(idC_lw,gr,"idC_lw",1), get_base1(idC_up,gr,"idC_up",1)), stan::model::nil_index_list()), "conc"),odeParam, pstream__), 
                            "assigning variable y_hat");
                stan::model::assign(Psurv_hat, 
                            stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), 
                            exp(minus(stan::model::rvalue(y_hat, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "y_hat"))), 
                            "assigning variable Psurv_hat");
                for (int i = get_base1(idS_lw,gr,"idS_lw",1); i <= get_base1(idS_up,gr,"idS_up",1); ++i) {

                    stan::math::assign(get_base1_lhs(Conditional_Psurv_hat,i,"Conditional_Psurv_hat",1), (logical_eq(i,get_base1(idS_lw,gr,"idS_lw",1)) ? stan::math::promote_scalar<double>(get_base1(Psurv_hat,i,"Psurv_hat",1)) : stan::math::promote_scalar<double>((get_base1(Psurv_hat,i,"Psurv_hat",1) / get_base1(Psurv_hat,(i - 1),"Psurv_hat",1))) ));
                }
            }

            // validate transformed parameters
            for (int k0__ = 0; k0__ < 4; ++k0__) {
                check_greater_or_equal(function__,"param[k0__]",param[k0__],0);
            }
            check_greater_or_equal(function__,"Psurv_hat",Psurv_hat,0);
            check_less_or_equal(function__,"Psurv_hat",Psurv_hat,1);
            check_greater_or_equal(function__,"Conditional_Psurv_hat",Conditional_Psurv_hat,0);
            check_less_or_equal(function__,"Conditional_Psurv_hat",Conditional_Psurv_hat,1);

            // write transformed parameters
        vars__.push_back(hb_log10);
        vars__.push_back(kd_log10);
        vars__.push_back(z_log10);
        vars__.push_back(kk_log10);
            for (int k_0__ = 0; k_0__ < 4; ++k_0__) {
            vars__.push_back(param[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < 2; ++k_1__) {
                for (int k_0__ = 0; k_0__ < n_data_Nsurv; ++k_0__) {
                vars__.push_back(y_hat(k_0__, k_1__));
                }
            }
            for (int k_0__ = 0; k_0__ < n_data_Nsurv; ++k_0__) {
            vars__.push_back(Psurv_hat[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < n_data_Nsurv; ++k_0__) {
            vars__.push_back(Conditional_Psurv_hat[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            validate_non_negative_index("Nsurv_ppc", "n_data_Nsurv", n_data_Nsurv);
            vector<int> Nsurv_ppc(n_data_Nsurv, 0);
            stan::math::fill(Nsurv_ppc, std::numeric_limits<int>::min());
            validate_non_negative_index("Nsurv_sim", "n_data_Nsurv", n_data_Nsurv);
            vector<int> Nsurv_sim(n_data_Nsurv, 0);
            stan::math::fill(Nsurv_sim, std::numeric_limits<int>::min());
            validate_non_negative_index("Nsurv_sim_prec", "n_data_Nsurv", n_data_Nsurv);
            vector<int> Nsurv_sim_prec(n_data_Nsurv, 0);
            stan::math::fill(Nsurv_sim_prec, std::numeric_limits<int>::min());
            validate_non_negative_index("log_lik", "n_data_Nsurv", n_data_Nsurv);
            vector_d log_lik(static_cast<Eigen::VectorXd::Index>(n_data_Nsurv));
            (void) log_lik;  // dummy to suppress unused var warning

            stan::math::initialize(log_lik, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_lik,DUMMY_VAR__);


            for (int gr = 1; gr <= n_group; ++gr) {

                for (int i = get_base1(idS_lw,gr,"idS_lw",1); i <= get_base1(idS_up,gr,"idS_up",1); ++i) {

                    stan::math::assign(get_base1_lhs(Nsurv_ppc,i,"Nsurv_ppc",1), binomial_rng(get_base1(Nprec,i,"Nprec",1),get_base1(Conditional_Psurv_hat,i,"Conditional_Psurv_hat",1), base_rng__));
                    stan::math::assign(get_base1_lhs(Nsurv_sim_prec,i,"Nsurv_sim_prec",1), (logical_eq(i,get_base1(idS_lw,gr,"idS_lw",1)) ? get_base1(Nprec,i,"Nprec",1) : get_base1(Nsurv_sim,(i - 1),"Nsurv_sim",1) ));
                    stan::math::assign(get_base1_lhs(Nsurv_sim,i,"Nsurv_sim",1), binomial_rng(get_base1(Nsurv_sim_prec,i,"Nsurv_sim_prec",1),get_base1(Conditional_Psurv_hat,i,"Conditional_Psurv_hat",1), base_rng__));
                    stan::math::assign(get_base1_lhs(log_lik,i,"log_lik",1), binomial_log(stan::model::rvalue(Nsurv, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "Nsurv"),stan::model::rvalue(Nprec, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "Nprec"),stan::model::rvalue(Conditional_Psurv_hat, stan::model::cons_list(stan::model::index_min_max(get_base1(idS_lw,gr,"idS_lw",1), get_base1(idS_up,gr,"idS_up",1)), stan::model::nil_index_list()), "Conditional_Psurv_hat")));
                }
            }

            // validate generated quantities

            // write generated quantities
            for (int k_0__ = 0; k_0__ < n_data_Nsurv; ++k_0__) {
            vars__.push_back(Nsurv_ppc[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < n_data_Nsurv; ++k_0__) {
            vars__.push_back(Nsurv_sim[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < n_data_Nsurv; ++k_0__) {
            vars__.push_back(Nsurv_sim_prec[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < n_data_Nsurv; ++k_0__) {
            vars__.push_back(log_lik[k_0__]);
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_ode_TKTD_varSD";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "hb_log10";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "kd_log10";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "z_log10";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "kk_log10";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "param" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_hat" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Psurv_hat" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Conditional_Psurv_hat" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Nsurv_ppc" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Nsurv_sim" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Nsurv_sim_prec" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "hb_log10";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "kd_log10";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "z_log10";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "kk_log10";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= 4; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "param" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "y_hat" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Psurv_hat" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Conditional_Psurv_hat" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Nsurv_ppc" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Nsurv_sim" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "Nsurv_sim_prec" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_data_Nsurv; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
    }

}; // model

}




#endif
