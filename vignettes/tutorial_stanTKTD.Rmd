---
title: "Getting started with 'morseStan'"
author: "Virgile Baudrot"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Load Packages and Data

```{r loadLibrary}
library(morse)
library(morseStan)
library(rstan)
```


## data from 'morse' pacakge - Propiconazole

```{r loadData}
data("propiconazole")
cst_data <- survData(propiconazole)
data("propiconazole_pulse_exposure")
var_data <- survData(propiconazole_pulse_exposure)
```

## Data of Diazinon

Those data are used in Albert et al. (2016)

```{r}
# Diazinon data set used in the GUTS R package Paper (Alber, Vogel & Ashauer 2016)
# Gammarus pulex exposed to diazinon
data_conc <- data.frame(
  conc = c(102.65,97.59,0,0,103.88,98.19,0,0,0,0, # C1
           100.78,106.32,0,0,103.56,95.82,0,0,0, # C2
           100.6,94.61,0,0,100.58,96.51,0,9.85), # C3
  time = c(0,1.02,1.03,2.99,3.01,4.01,4.02,11.01,18.01,22.01, # C1
           0,1.02,1.03,8,8.01,9,9.01,15,22.01, # C2
           0,1.02,1.03,16,16.01,17,17.01,22.01), #C3
  replicate = rep(c("R1", "R2", "R3"),c(10,9,8))
)

data_Nsurv <- data.frame(
  Nsurv = as.integer(c(70,66,61,55,31,31,29,26,24,22,21,19,17,14,14,13,11,11,10,9,8,8,8, # C1
            70,65,59,56,54,50,47,46,46,40,23,22,22,21,18,17,17,13,13,13,11,11,11, # C2
            70,65,59,55,53,51,48,46,46,46,44,41,40,40,40,39,38,36,33,28,24,23,19)), # C3
  time = c(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22, # C1
           0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22, # C2
           0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22), #C3
  replicate = rep(c("R1", "R2", "R3"), each=23)
)

data_Diazinon <- survData( survData_join(data_Nsurv, data_conc) )
```

# Model fitting


## Parallel
Model fitting can be long to compute, especially when the profile of exposure is highly variable. Do be faster, a good solution is to consider several cores.


```{r}
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores() - 1)
## OR 
# options(mc.cores = 3)
```

Then, the next step is very easy.

By default, all `morsestan` modeling functions will run four randomly initialized Markov chains, each for 2000 iterations (including a warmup period of 1000 iterations that is discarded).
All chains must converge to the target distribution for inferences to be valid. For most models, the default settings are sufficient, but if you see a warning message about Markov chains not converging, the first thing to try is increasing the number of iterations. This can be done by specifying the iter argument (e.g. iter = 3000).

## GUTS-SD

```{r}
fit_cstSD <- stan_guts(cst_data, model_type = "SD", iter = 2000, warmup=500, chains = 3) 
```

```{r}
#fit_varSD <- stan_guts(var_data, model_type = "SD", iter = 2000, warmup=500, chains = 3)
```

## GUTS-IT

```{r}
fit_cstIT <- stan_guts(cst_data, model_type = "IT", iter = 2000, warmup = 500, chains = 3)
```

```{r}
#fit_varIT <- stan_guts(var_data, model_type = "IT", iter = 2000, warmup = 500, chains = 3)
```


# Model Summary

```{r}
summary(fit_cstSD)$Qposteriors

summary(fit_varSD)

summary(fit_cstIT)

summary(fit_varIT)
```


# Model Plot

```{r}
plot(fit_cstSD, data_type = 'Number')
plot(fit_cstSD, data_type = 'Rate')

plot(fit_varSD, data_type = 'Number')
plot(fit_varSD, data_type = 'Rate')


plot(fit_cstIT, data_type = 'Number')
plot(fit_cstIT, data_type = 'Rate')

plot(fit_varIT, data_type = 'Number')
plot(fit_varIT, data_type = 'Rate')
```

# Model exploration

```{r}
ppc(fit_cstSD)
ppc(fit_varSD)
ppc(fit_cstIT)
ppc(fit_varIT)
```

# Pairs plot

```{r}
pairs(fit_cstSD$stanfit, pars = c("hb_log10", "kd_log10", "z_log10", "kk_log10"))

pairs(fit_varSD$stanfit, pars = c("hb_log10", "kd_log10", "z_log10", "kk_log10"))

pairs(fit_cstIT$stanfit, pars = c("hb_log10", "kd_log10", "alpha_log10", "beta_log10"))

pairs(fit_varIT$stanfit, pars = c("hb_log10", "kd_log10", "alpha_log10", "beta_log10"))
```

# Goodness-of-Fit Analysis

0. extract requires object

```{r exctractObjects}
params <- extract_MCMCparameters_name(fit_Car_cstSD)
params_wLP <- c(extract_MCMCparameters_name(fit_Car_cstSD), "lp__")
fit_stan_guts <- fit_Car_cstSD
fit <- extract_stanfit(fit_Car_cstSD)
posterior <- as.array(fit)

rhats <- rhat(fit)

ratios_cp <- neff_ratio(fit)
```


1. Checking MCMC and posteriors

```{r MCMC}
mcmc_combo(posterior, pars = params_wLP, combo = c("dens_overlay", "trace"))
```

2. Pairs plot: Correlation between parameters

```{r correlation}
mcmc_pairs(posterior, pars = params, off_diag_fun = "hex")
```

3. Rhat statistics

* light: below 1.05 (good)
* mid: between 1.05 and 1.1 (ok)
* dark: above 1.1 (too high)

```{r Rhat}
mcmc_rhat(rhats[params]) + yaxis_text(hjust = 0)
```

4. ratios of effective sample size to total sample size

* light: between 0.5 and 1 (high)
* mid: between 0.1 and 0.5 (good)
* dark: below 0.1 (low)

```{r neff}
mcmc_neff(ratios_cp[params]) + yaxis_text(hjust = 0)
```

5. Autocorrelation of MCMC draws

```{r acf}
mcmc_acf(posterior, pars = params, lags = 10)
```

6. Posteriors predictive check

```{r ppc}
ppc(fit_stan_guts)
```

```{r}
ppc_loo_intervals(y_fit, yrep_fit, lw = lw_fit, prob = 0.95)
```


```{r}
ppc_loo_pit(y_fit, yrep_fit, lw = lw_fit, prob = 0.95)
```


